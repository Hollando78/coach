{"version":3,"file":"basisTextureLoader-B6da9usx.js","sources":["../../../node_modules/.pnpm/@babylonjs+core@7.54.3/node_modules/@babylonjs/core/Materials/Textures/Loaders/basisTextureLoader.js"],"sourcesContent":["import { LoadTextureFromTranscodeResult, TranscodeAsync } from \"../../../Misc/basis.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\n/**\n * Loader for .basis file format\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _BasisTextureLoader {\n    constructor() {\n        /**\n         * Defines whether the loader supports cascade loading the different faces.\n         */\n        this.supportCascades = false;\n    }\n    /**\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param createPolynomials will be true if polynomials have been requested\n     * @param onLoad defines the callback to trigger once the texture is ready\n     * @param onError defines the callback to trigger in case of error\n     */\n    loadCubeData(data, texture, createPolynomials, onLoad, onError) {\n        if (Array.isArray(data)) {\n            return;\n        }\n        const caps = texture.getEngine().getCaps();\n        const transcodeConfig = {\n            supportedCompressionFormats: {\n                etc1: caps.etc1 ? true : false,\n                s3tc: caps.s3tc ? true : false,\n                pvrtc: caps.pvrtc ? true : false,\n                etc2: caps.etc2 ? true : false,\n                astc: caps.astc ? true : false,\n                bc7: caps.bptc ? true : false,\n            },\n        };\n        TranscodeAsync(data, transcodeConfig)\n            .then((result) => {\n            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n            LoadTextureFromTranscodeResult(texture, result);\n            texture.getEngine()._setCubeMapTextureParams(texture, hasMipmap);\n            texture.isReady = true;\n            texture.onLoadedObservable.notifyObservers(texture);\n            texture.onLoadedObservable.clear();\n            if (onLoad) {\n                onLoad();\n            }\n        })\n            .catch((err) => {\n            const errorMessage = \"Failed to transcode Basis file, transcoding may not be supported on this device\";\n            Tools.Warn(errorMessage);\n            texture.isReady = true;\n            if (onError) {\n                onError(err);\n            }\n        });\n    }\n    /**\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n     * @param data contains the texture data\n     * @param texture defines the BabylonJS internal texture\n     * @param callback defines the method to call once ready to upload\n     */\n    loadData(data, texture, callback) {\n        const caps = texture.getEngine().getCaps();\n        const transcodeConfig = {\n            supportedCompressionFormats: {\n                etc1: caps.etc1 ? true : false,\n                s3tc: caps.s3tc ? true : false,\n                pvrtc: caps.pvrtc ? true : false,\n                etc2: caps.etc2 ? true : false,\n                astc: caps.astc ? true : false,\n                bc7: caps.bptc ? true : false,\n            },\n        };\n        TranscodeAsync(data, transcodeConfig)\n            .then((result) => {\n            const rootImage = result.fileInfo.images[0].levels[0];\n            const hasMipmap = result.fileInfo.images[0].levels.length > 1 && texture.generateMipMaps;\n            callback(rootImage.width, rootImage.height, hasMipmap, result.format !== -1, () => {\n                LoadTextureFromTranscodeResult(texture, result);\n            });\n        })\n            .catch((err) => {\n            Tools.Warn(\"Failed to transcode Basis file, transcoding may not be supported on this device\");\n            Tools.Warn(`Failed to transcode Basis file: ${err}`);\n            callback(0, 0, false, false, () => { }, true);\n        });\n    }\n}\n//# sourceMappingURL=basisTextureLoader.js.map"],"names":["_BasisTextureLoader","constructor","this","supportCascades","loadCubeData","data","texture","createPolynomials","onLoad","onError","Array","isArray","caps","getEngine","getCaps","transcodeConfig","supportedCompressionFormats","etc1","s3tc","pvrtc","etc2","astc","bc7","bptc","TranscodeAsync","then","result","hasMipmap","fileInfo","images","levels","length","generateMipMaps","LoadTextureFromTranscodeResult","_setCubeMapTextureParams","isReady","onLoadedObservable","notifyObservers","clear","catch","err","Tools","Warn","loadData","callback","rootImage","width","height","format"],"mappings":"sDAOO,MAAMA,EACT,WAAAC,GAIIC,KAAKC,iBAAkB,CAC3B,CASA,YAAAC,CAAaC,EAAMC,EAASC,EAAmBC,EAAQC,GACnD,GAAIC,MAAMC,QAAQN,GACd,OAEJ,MAAMO,EAAON,EAAQO,YAAYC,UAC3BC,EAAkB,CACpBC,4BAA6B,CACzBC,OAAML,EAAKK,KACXC,OAAMN,EAAKM,KACXC,QAAOP,EAAKO,MACZC,OAAMR,EAAKQ,KACXC,OAAMT,EAAKS,KACXC,MAAKV,EAAKW,OAGlBC,EAAenB,EAAMU,GAChBU,KAAMC,IACP,MAAMC,EAAYD,EAAOE,SAASC,OAAO,GAAGC,OAAOC,OAAS,GAAKzB,EAAQ0B,gBACzEC,EAA+B3B,EAASoB,GACxCpB,EAAQO,YAAYqB,yBAAyB5B,EAASqB,GACtDrB,EAAQ6B,SAAU,EAClB7B,EAAQ8B,mBAAmBC,gBAAgB/B,GAC3CA,EAAQ8B,mBAAmBE,QACvB9B,GACAA,MAGH+B,MAAOC,IAERC,EAAMC,KADe,mFAErBpC,EAAQ6B,SAAU,EACd1B,GACAA,EAAQ+B,IAGpB,CAOA,QAAAG,CAAStC,EAAMC,EAASsC,GACpB,MAAMhC,EAAON,EAAQO,YAAYC,UAC3BC,EAAkB,CACpBC,4BAA6B,CACzBC,OAAML,EAAKK,KACXC,OAAMN,EAAKM,KACXC,QAAOP,EAAKO,MACZC,OAAMR,EAAKQ,KACXC,OAAMT,EAAKS,KACXC,MAAKV,EAAKW,OAGlBC,EAAenB,EAAMU,GAChBU,KAAMC,IACP,MAAMmB,EAAYnB,EAAOE,SAASC,OAAO,GAAGC,OAAO,GAC7CH,EAAYD,EAAOE,SAASC,OAAO,GAAGC,OAAOC,OAAS,GAAKzB,EAAQ0B,gBACzEY,EAASC,EAAUC,MAAOD,EAAUE,OAAQpB,GAA6B,IAAlBD,EAAOsB,OAAe,KACzEf,EAA+B3B,EAASoB,OAG3Ca,MAAOC,IACRC,EAAMC,KAAK,mFACXD,EAAMC,KAAK,mCAAmCF,KAC9CI,EAAS,EAAG,GAAG,GAAO,EAAO,QAAW,IAEhD","x_google_ignoreList":[0]}