function t(t){return Math.floor(t/8)}function e(t){return 1<<t%8}class r{constructor(t){this.size=t,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(r){if(r>=this.size)throw new RangeError("Bit index out of range");const o=t(r),n=e(r);return 0!==(this._byteArray[o]&n)}set(r,o){if(r>=this.size)throw new RangeError("Bit index out of range");const n=t(r),s=e(r);o?this._byteArray[n]|=s:this._byteArray[n]&=~s}}function o(t){const e=[],o=t.length/3;for(let r=0;r<o;r++)e.push([t[3*r],t[3*r+1],t[3*r+2]]);const n=new Map;e.forEach((t,e)=>{t.forEach(t=>{let r=n.get(t);r||n.set(t,r=[]),r.push(e)})});const s=new r(o),h=[],i=t=>{const r=[t];for(;r.length>0;){const t=r.pop();s.get(t)||(s.set(t,!0),h.push(e[t]),e[t].forEach(t=>{const e=n.get(t);e&&e.forEach(t=>{s.get(t)||r.push(t)})}))}};for(let r=0;r<o;r++)s.get(r)||i(r);let c=0;h.forEach(e=>{t[c++]=e[0],t[c++]=e[1],t[c++]=e[2]})}export{o as OptimizeIndices};
//# sourceMappingURL=mesh.vertexData.functions-wh821X3u.js.map
