<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#2F4F2F">
    <title>üêâ Dragon Hatchers - World Map</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.2/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
            -ms-touch-action: none;
            -webkit-touch-action: none;
            overscroll-behavior: none;
            -webkit-overscroll-behavior: none;
        }
        
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }

        #worldView {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
        }

        #worldView:active {
            cursor: grabbing;
        }

        #worldContainer {
            position: relative;
            width: 2000px;
            height: 1500px;
            background: 
                radial-gradient(circle at 300px 200px, rgba(135, 206, 235, 0.8) 0%, transparent 30%),
                radial-gradient(circle at 1700px 300px, rgba(135, 206, 235, 0.8) 0%, transparent 25%),
                radial-gradient(circle at 1200px 1200px, rgba(135, 206, 235, 0.8) 0%, transparent 35%),
                linear-gradient(45deg, #228B22 0%, #32CD32 30%, #90EE90 60%, #F0E68C 80%, #8B4513 100%);
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }
        
        #worldContainer::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 400px 600px, rgba(34, 139, 34, 0.3) 20%, transparent 25%),
                radial-gradient(circle at 800px 400px, rgba(34, 139, 34, 0.3) 15%, transparent 20%),
                radial-gradient(circle at 1600px 800px, rgba(34, 139, 34, 0.3) 25%, transparent 30%),
                radial-gradient(circle at 1000px 1000px, rgba(34, 139, 34, 0.3) 20%, transparent 25%);
            pointer-events: none;
        }
        
        #worldContainer::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background-image:
                repeating-linear-gradient(45deg, transparent 0%, transparent 98%, rgba(139, 69, 19, 0.1) 99%, rgba(139, 69, 19, 0.1) 100%),
                repeating-linear-gradient(-45deg, transparent 0%, transparent 97%, rgba(34, 139, 34, 0.1) 98%, rgba(34, 139, 34, 0.1) 100%);
            background-size: 100px 100px, 80px 80px;
            pointer-events: none;
        }

        .pixi-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* Movement Controls */
        .movement-controls {
            position: fixed;
            bottom: 80px;
            left: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
            user-select: none;
        }

        .move-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .move-btn {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 2px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        .move-btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }

        .move-btn:active {
            background: rgba(100, 100, 255, 0.8);
            transform: scale(0.95);
        }

        .center-btn {
            background: rgba(50, 50, 50, 0.5);
            cursor: default;
        }

        .center-btn:hover {
            background: rgba(50, 50, 50, 0.5);
            transform: none;
        }
        
        .diagonal-btn {
            width: 45px;
            height: 45px;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .diagonal-btn:hover {
            background: rgba(0, 0, 0, 0.8);
        }

        @media (max-width: 768px) {
            .movement-controls {
                bottom: 120px;
                left: 15px;
            }
            
            .move-btn {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
        }

        /* Progress bars and stats */
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin: 2px 0;
        }
        
        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .stat-bar {
            margin: 8px 0;
        }
        
        .stat-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 5px;
        }
        
        .inventory-stats {
            margin-bottom: 15px;
        }
        
        .currency {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .resources {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .battle-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .player-stats, .enemy-stats {
            width: 45%;
        }
        
        .dragon-actions, .inventory-actions, .battle-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .dragon-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .dragon-info h4 {
            margin: 0 0 5px 0;
            font-size: 16px;
        }
        
        .dragon-info p {
            margin: 3px 0;
            font-size: 12px;
            opacity: 0.9;
        }

        /* UI Overlays */
        .inventory-toggle {
            position: fixed;
            right: 20px;
            top: 130px;
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #4f46e5, #7c3aed);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        .inventory-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .inventory-panel {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 350px;
            max-height: 80vh;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: none;
            z-index: 1001;
            overflow-y: auto;
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f3f4f6;
        }

        .inventory-header h3 {
            margin: 0;
            color: #1f2937;
            font-size: 1.2em;
        }

        #statusBar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 10px;
            text-align: center;
            font-size: 1.1em;
            z-index: 1000;
        }

        /* Location popup styles */
        .location-popup {
            position: fixed;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 2000;
            max-width: 400px;
            display: none;
        }

        .close-btn {
            position: absolute;
            right: 10px;
            top: 10px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-btn {
            background: linear-gradient(45deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            font-size: 1em;
        }

        .action-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        /* Enhanced Mini-map */
        #miniMap {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 180px;
            height: 120px;
            background: linear-gradient(135deg, #87ceeb 0%, #98fb98 50%, #f0e68c 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            z-index: 1000;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        #miniMapCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #miniPlayer {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, #ff0000 0%, #ffffff 50%, #ff0000 100%);
            border-radius: 50%;
            z-index: 1002;
            border: 1px solid white;
            box-shadow: 0 0 4px rgba(255,0,0,0.8);
        }

        .miniMapFeature {
            position: absolute;
            border-radius: 50%;
            z-index: 1001;
        }

        .miniMapMountain {
            background: #696969;
            border: 1px solid #ffffff;
        }

        .miniMapWater {
            background: #4169e1;
            border: 1px solid #87ceeb;
            animation: waterShimmer 2s infinite;
        }

        @keyframes waterShimmer {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1.0; }
        }

        .miniMapTree {
            background: #228b22;
            border: 1px solid #32cd32;
        }

        .miniMapPath {
            background: #8b4513;
            border-radius: 2px;
        }

        #miniMapLegend {
            position: fixed;
            top: 150px;
            right: 20px;
            width: 180px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px;
            border-radius: 8px;
            font-size: 10px;
            line-height: 1.2;
            z-index: 999;
            display: none;
        }

        /* Control buttons */
        .controls {
            position: fixed;
            top: 140px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 1000;
        }

        .zoom-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        /* Battle animations */
        @keyframes attackRight {
            0% {
                left: 80px;
                transform: scale(1);
            }
            50% {
                left: 150px;
                transform: scale(1.2);
            }
            100% {
                left: 200px;
                transform: scale(0.8);
                opacity: 0;
            }
        }

        @keyframes attackLeft {
            0% {
                right: 80px;
                transform: scale(1);
            }
            50% {
                right: 150px;
                transform: scale(1.2);
            }
            100% {
                right: 200px;
                transform: scale(0.8);
                opacity: 0;
            }
        }

        @keyframes hit {
            0% { transform: translateX(0) scale(1.5); }
            25% { transform: translateX(-5px) scale(1.5); filter: brightness(0.5); }
            50% { transform: translateX(5px) scale(1.5); filter: brightness(1.5); }
            75% { transform: translateX(-3px) scale(1.5); filter: brightness(0.8); }
            100% { transform: translateX(0) scale(1.5); filter: brightness(1); }
        }

        @keyframes pulse {
            0% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
            100% { opacity: 0.3; transform: scale(1); }
        }

        /* Inventory Tab Styling */
        .tab-btn {
            background: #4b5563;
            color: white;
            border: none;
            padding: 6px 12px;
            margin-right: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            transition: background-color 0.3s;
        }

        .tab-btn:hover {
            background: #6b7280;
        }

        .tab-btn.active {
            background: #059669;
        }

        .inventory-tab-content {
            padding: 5px 0;
        }

        .item-slot {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin: 2px 0;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            border-left: 3px solid transparent;
        }

        .item-slot:hover {
            background: rgba(0,0,0,0.3);
        }

        .item-slot.common { border-left-color: #9ca3af; }
        .item-slot.uncommon { border-left-color: #a855f7; }
        .item-slot.rare { border-left-color: #f59e0b; }

        .item-details {
            flex: 1;
            margin-left: 8px;
        }

        .item-name {
            font-weight: bold;
            font-size: 12px;
        }

        .item-description {
            font-size: 10px;
            color: #9ca3af;
            margin-top: 2px;
        }

        .item-actions {
            display: flex;
            gap: 5px;
        }

        .item-btn {
            background: #059669;
            color: white;
            border: none;
            padding: 2px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        .item-btn:hover {
            background: #047857;
        }

        .item-btn.sell {
            background: #dc2626;
        }

        .item-btn.sell:hover {
            background: #b91c1c;
        }
    </style>
</head>
<body>
    <div id="worldView">
        <div id="worldContainer">
            <!-- PixiJS canvas will be inserted here -->
        </div>
    </div>

    <!-- UI Overlays -->
    <div id="statusBar">Welcome to Dragon Hatchers! Use WASD or arrow keys to move around.</div>
    
    <!-- On-screen movement controls -->
    <div class="movement-controls">
        <div class="move-row">
            <div class="move-btn diagonal-btn" data-dir="up-left" onmousedown="startMove('up-left')" onmouseup="stopMove('up-left')" ontouchstart="startMove('up-left')" ontouchend="stopMove('up-left')">‚Üñ</div>
            <div class="move-btn" data-dir="up" onmousedown="startMove('up')" onmouseup="stopMove('up')" ontouchstart="startMove('up')" ontouchend="stopMove('up')">‚¨Ü</div>
            <div class="move-btn diagonal-btn" data-dir="up-right" onmousedown="startMove('up-right')" onmouseup="stopMove('up-right')" ontouchstart="startMove('up-right')" ontouchend="stopMove('up-right')">‚Üó</div>
        </div>
        <div class="move-row">
            <div class="move-btn" data-dir="left" onmousedown="startMove('left')" onmouseup="stopMove('left')" ontouchstart="startMove('left')" ontouchend="stopMove('left')">‚¨Ö</div>
            <div class="move-btn center-btn">üéØ</div>
            <div class="move-btn" data-dir="right" onmousedown="startMove('right')" onmouseup="stopMove('right')" ontouchstart="startMove('right')" ontouchend="stopMove('right')">‚û°</div>
        </div>
        <div class="move-row">
            <div class="move-btn diagonal-btn" data-dir="down-left" onmousedown="startMove('down-left')" onmouseup="stopMove('down-left')" ontouchstart="startMove('down-left')" ontouchend="stopMove('down-left')">‚Üô</div>
            <div class="move-btn" data-dir="down" onmousedown="startMove('down')" onmouseup="stopMove('down')" ontouchstart="startMove('down')" ontouchend="stopMove('down')">‚¨á</div>
            <div class="move-btn diagonal-btn" data-dir="down-right" onmousedown="startMove('down-right')" onmouseup="stopMove('down-right')" ontouchstart="startMove('down-right')" ontouchend="stopMove('down-right')">‚Üò</div>
        </div>
    </div>

    <!-- Enhanced Mini Map -->
    <div id="miniMap" onclick="toggleMiniMapLegend()" title="Click to toggle legend">
        <canvas id="miniMapCanvas" width="180" height="120"></canvas>
        <div id="miniPlayer"></div>
    </div>

    <!-- Mini Map Legend -->
    <div id="miniMapLegend">
        <div style="margin-bottom: 4px; font-weight: bold; color: #ffd700;">üó∫Ô∏è Map Legend</div>
        <div>üî¥ You ‚Ä¢ üèîÔ∏è Mountains ‚Ä¢ üíß Water</div>
        <div>üå≥ Forest ‚Ä¢ üõ§Ô∏è Paths ‚Ä¢ üå∏ Flowers</div>
        <div>üóø Rocks ‚Ä¢ üê≤ Dragons ‚Ä¢ üëπ Monsters</div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="zoom-btn" onclick="zoomIn()" title="Zoom In (+)">üîç+</button>
        <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out (-)">üîç-</button>
        <button class="zoom-btn" onclick="resetZoom()" title="Reset Zoom (0)">1:1</button>
        <button class="zoom-btn" onclick="centerCamera()" title="Center Camera (C)">üìç</button>
    </div>

    <!-- Inventory Toggle -->
    <div class="inventory-toggle" onclick="toggleInventory()" title="Inventory (I)">üéí</div>
    <div class="inventory-toggle" onclick="toggleDragonCare()" title="Dragon Care" style="top: 190px; background: linear-gradient(45deg, #ff9800, #f57c00);">üê≤</div>
    <div class="inventory-toggle" onclick="toggleBattle()" title="Battle" style="top: 250px; background: linear-gradient(45deg, #dc2626, #b91c1c);">‚öîÔ∏è</div>
    <div class="inventory-toggle" onclick="toggleSettings()" title="Settings" style="top: 310px; background: linear-gradient(45deg, #6b7280, #4b5563);">‚öôÔ∏è</div>

    <!-- Inventory Panel -->
    <div class="inventory-panel" id="inventoryPanel" style="width: 400px; height: 500px;">
        <div class="inventory-header">
            <h3>üéí Inventory</h3>
            <div style="font-size: 10px; color: #ccc;">
                <span id="inventorySlots">0/50</span> slots | Value: <span id="inventoryValue">0</span>g
            </div>
            <button onclick="closeInventory()" style="background: #dc2626; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer;">√ó</button>
        </div>
        <div id="inventoryContent" style="height: 420px; overflow-y: auto;">
            <!-- Inventory Tabs -->
            <div class="inventory-tabs" style="display: flex; margin-bottom: 10px;">
                <button class="tab-btn active" onclick="showInventoryTab('basic')" id="basicTab">üì¶ Basic</button>
                <button class="tab-btn" onclick="showInventoryTab('equipment')" id="equipmentTab">‚öîÔ∏è Equipment</button>
                <button class="tab-btn" onclick="showInventoryTab('consumables')" id="consumablesTab">üíä Items</button>
                <button class="tab-btn" onclick="showInventoryTab('materials')" id="materialsTab">‚õèÔ∏è Materials</button>
            </div>
            
            <!-- Basic Tab -->
            <div id="basicInventory" class="inventory-tab-content">
                <div class="inventory-stats">
                    <div class="currency">
                        <span>üí∞ Gold: <span id="goldAmount">100</span></span>
                    </div>
                    <div class="resources">
                        <span>ü™µ Wood: <span id="woodAmount">0</span></span>
                        <span>üçñ Food: <span id="foodAmount">5</span></span>
                        <span>üíä Potions: <span id="potionAmount">2</span></span>
                    </div>
                </div>
                <div class="inventory-actions">
                    <button class="action-btn" onclick="buyFood()">üõí Buy Food (10 Gold)</button>
                    <button class="action-btn" onclick="buyPotion()">üõí Buy Potion (20 Gold)</button>
                    <button class="action-btn" onclick="sellWood()">üí∞ Sell Wood (5 Gold each)</button>
                    <button class="action-btn" onclick="buyDragonTreats()">üõí Buy Dragon Treats (15 Gold)</button>
                </div>
            </div>
            
            <!-- Equipment Tab -->
            <div id="equipmentInventory" class="inventory-tab-content" style="display: none;">
                <div id="equipmentDisplay"></div>
            </div>
            
            <!-- Consumables Tab -->
            <div id="consumablesInventory" class="inventory-tab-content" style="display: none;">
                <div id="consumablesDisplay"></div>
            </div>
            
            <!-- Materials Tab -->
            <div id="materialsInventory" class="inventory-tab-content" style="display: none;">
                <div id="materialsDisplay"></div>
            </div>
        </div>
    </div>

    <!-- Dragon Care Panel -->
    <div class="inventory-panel" id="dragonCarePanel" style="display: none;">
        <div class="inventory-header">
            <h3>üê≤ Dragon Care</h3>
            <button onclick="closeDragonCare()" style="background: #dc2626; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer;">√ó</button>
        </div>
        <div id="dragonCareContent">
            <div style="display: flex; gap: 20px;">
                <!-- Dragon Sprite Display -->
                <div id="dragonSpriteContainer" style="width: 150px; height: 150px; background: linear-gradient(135deg, #e8f5e9, #c8e6c9); border-radius: 10px; display: flex; align-items: center; justify-content: center; border: 2px solid #4caf50;">
                    <!-- PixiJS canvas will be inserted here -->
                </div>
                
                <!-- Dragon Info -->
                <div class="dragon-info" style="flex: 1;">
                    <h4 id="dragonNameType">üê≤ Drago (Fire Dragon)</h4>
                    <p id="dragonPersonality">Personality: Friendly</p>
                    <p id="dragonTraits">Wings: Yes, Horns: Yes</p>
                </div>
            </div>
            <div class="dragon-stats" style="margin-top: 15px;">
                <div class="stat-bar">
                    <span>‚ù§Ô∏è Health: <span id="dragonHealth">100</span>/100</span>
                    <div class="progress-bar"><div id="healthBar" class="progress-fill" style="width: 100%; background: #ff4444;"></div></div>
                </div>
                <div class="stat-bar">
                    <span>üòä Happiness: <span id="dragonHappiness">100</span>/100</span>
                    <div class="progress-bar"><div id="happinessBar" class="progress-fill" style="width: 100%; background: #44ff44;"></div></div>
                </div>
                <div class="stat-bar">
                    <span>üçñ Hunger: <span id="dragonHunger">100</span>/100</span>
                    <div class="progress-bar"><div id="hungerBar" class="progress-fill" style="width: 100%; background: #4444ff;"></div></div>
                </div>
                <div class="stat-info">
                    <span>üèÜ Level: <span id="dragonLevel">1</span></span>
                    <span>‚ú® EXP: <span id="dragonExp">0</span></span>
                </div>
            </div>
            <div class="dragon-actions">
                <button class="action-btn" onclick="feedDragon()">üçñ Feed Dragon (Food: <span id="foodCount">5</span>)</button>
                <button class="action-btn" onclick="playWithDragon()">üéæ Play with Dragon</button>
                <button class="action-btn" onclick="healDragon()">üíä Give Medicine (Potions: <span id="potionCount">2</span>)</button>
            </div>
        </div>
    </div>

    <!-- Battle Panel -->
    <div class="inventory-panel" id="battlePanel" style="display: none;">
        <div class="inventory-header">
            <h3>‚öîÔ∏è Battle Arena</h3>
            <button onclick="closeBattle()" style="background: #dc2626; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer;">√ó</button>
        </div>
        <div id="battleContent">
            <div id="battleInfo" style="display: none;">
                <div class="battle-stats">
                    <div class="player-stats">
                        <h4 id="dragonBattleName">üêâ Dragon</h4>
                        <div class="progress-bar"><div id="playerHealthBar" class="progress-fill" style="background: #44ff44;"></div></div>
                        <span>HP: <span id="playerHP">100</span>/<span id="playerMaxHP">100</span></span>
                    </div>
                    <div class="enemy-stats">
                        <h4 id="enemyName">üëπ Enemy</h4>
                        <div class="progress-bar"><div id="enemyHealthBar" class="progress-fill" style="background: #ff4444;"></div></div>
                        <span>HP: <span id="enemyHP">40</span>/<span id="enemyMaxHP">40</span></span>
                    </div>
                </div>
                
                <!-- Battle Arena Visual -->
                <div id="battleArena" style="height: 120px; background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 50%, #8FBC8F 100%); border: 2px solid #654321; border-radius: 10px; margin: 10px 0; position: relative; overflow: hidden;">
                    <!-- Dragon sprite -->
                    <div id="battleDragonSprite" style="position: absolute; left: 20px; bottom: 10px; transform: scale(1.5); transform-origin: bottom center;"></div>
                    <!-- Monster sprite -->
                    <div id="battleMonsterSprite" style="position: absolute; right: 20px; bottom: 10px; transform: scale(1.5); transform-origin: bottom center;"></div>
                    <!-- Attack effects -->
                    <div id="attackEffects" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
                </div>
                
                <div id="battleLog" style="max-height: 100px; overflow-y: auto; margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 5px;"></div>
                <div class="battle-actions" id="battleActions">
                    <button class="action-btn" onclick="dragonAttack()">üó°Ô∏è Attack</button>
                    <button class="action-btn" onclick="dragonDefend()">üõ°Ô∏è Defend</button>
                    <button class="action-btn" id="specialAttackBtn" onclick="dragonSpecialAttack()">üî• Special Attack</button>
                    <button class="action-btn" onclick="usePotion()">üíä Use Potion</button>
                    <button class="action-btn" onclick="fleeBattle()">üèÉ Flee</button>
                </div>
            </div>
            <div id="noBattleInfo">
                <p>No active battle. Find monsters in the world to fight!</p>
            </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="inventory-panel" id="settingsPanel" style="display: none;">
        <div class="inventory-header">
            <h3>‚öôÔ∏è Settings</h3>
            <button onclick="closeSettings()" style="background: #dc2626; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer;">√ó</button>
        </div>
        <div id="settingsContent">
            <button class="action-btn" onclick="saveGame()">üíæ Save Game</button>
            <button class="action-btn" onclick="loadGame()">üìÅ Load Game</button>
        </div>
    </div>

    <!-- Location Popup -->
    <div class="location-popup" id="locationPopup">
        <button class="close-btn" onclick="closePopup()">√ó</button>
        <h3 id="popupTitle">Location</h3>
        <p id="popupDescription">Description</p>
        <div id="popupActions"></div>
    </div>

    <script>
        // Game variables
        let currentZoom = 1;
        let playerPosition = { x: 1000, y: 650 };
        let cameraPosition = { x: 0, y: 0 };
        let targetCameraPosition = { x: 0, y: 0 };
        let smoothCameraFollow = true;
        let keysPressed = {};
        let isMoving = false;
        let moveSpeed = 5;
        let gameFrame = 0;

        // PixiJS variables
        let pixiApp = null;
        let pixiContainer = null;
        let backgroundContainer = null;
        let entityContainer = null;
        let playerSprite = null;
        let dragonSprite = null;
        let dragonCareApp = null; // Separate app for dragon care panel
        let dragonCareSprite = null;
        let playerDirection = 'down'; // Track player facing direction
        
        // Game objects tracking
        let worldObjects = {
            trees: [],
            sheep: [],
            structures: [],
            monsters: [],
            wanderingDragons: []
        };
        
        // Dragon care system
        let dragonStats = {
            health: 100,
            happiness: 100,
            hunger: 100,
            level: 1,
            experience: 0,
            name: 'Drago',
            type: 'fire', // fire, ice, earth, storm, shadow
            personality: 'friendly', // friendly, fierce, playful, wise, mischievous
            traits: {
                hasWings: true,
                hasHorns: true,
                tailType: 'spiked',
                bodyColor: 0xFF4444,
                accentColor: 0xFF8800,
                eyeColor: 0xFF0000,
                size: 1.0
            },
            position: { x: 0, y: 0 },
            targetPosition: { x: 0, y: 0 },
            animations: {
                idle: { frame: 0, timer: 0 },
                flying: false,
                emotion: 'neutral'
            }
        };
        
        // Player inventory
        let playerInventory = {
            gold: 100,
            wood: 0,
            food: 5,
            potions: 2,
            equipment: [],
            consumables: {
                dragonTreats: 0,
                healingPowders: 0,
                strengthPotions: 0,
                magicCrystals: 0
            },
            materials: {
                ironOre: 0,
                dragonScales: 0,
                magicEssence: 0,
                rareGems: 0
            },
            keyItems: [],
            maxSlots: 50,
            usedSlots: 0
        };

        // Enhanced consumable items database
        const consumableItems = {
            dragonTreats: { 
                name: 'Dragon Treats', 
                icon: 'üçñ', 
                description: 'Delicious treats that make dragons very happy',
                effect: { happiness: 40, hunger: 20 },
                value: 15
            },
            healingPowders: { 
                name: 'Healing Powder', 
                icon: 'üíä', 
                description: 'Magical powder that restores dragon health',
                effect: { health: 50 },
                value: 25
            },
            strengthPotions: { 
                name: 'Strength Potion', 
                icon: 'üß™', 
                description: 'Temporarily boosts dragon combat power',
                effect: { tempAttack: 10, duration: 5 },
                value: 30
            },
            magicCrystals: { 
                name: 'Magic Crystal', 
                icon: 'üíé', 
                description: 'Rare crystals that boost dragon experience',
                effect: { experience: 25 },
                value: 50
            }
        };

        // Material items database
        const materialItems = {
            ironOre: { 
                name: 'Iron Ore', 
                icon: '‚õèÔ∏è', 
                description: 'Raw iron for crafting equipment',
                value: 5
            },
            dragonScales: { 
                name: 'Dragon Scales', 
                icon: 'üêâ', 
                description: 'Shed dragon scales, valuable crafting material',
                value: 20
            },
            magicEssence: { 
                name: 'Magic Essence', 
                icon: '‚ú®', 
                description: 'Concentrated magical energy',
                value: 35
            },
            rareGems: { 
                name: 'Rare Gems', 
                icon: 'üíé', 
                description: 'Precious gems used in advanced crafting',
                value: 100
            }
        };
        
        // Battle system
        let battleState = {
            inBattle: false,
            enemy: null,
            dragonHP: 100,
            dragonMaxHP: 100,
            turn: 'player',
            specialAttackCooldown: 0
        };

        // Dragon special attacks based on type
        const dragonSpecialAttacks = {
            fire: { name: 'Flame Burst', icon: 'üî•', baseDamage: 35, cooldown: 2, effect: 'burn' },
            ice: { name: 'Frost Breath', icon: '‚ùÑÔ∏è', baseDamage: 30, cooldown: 2, effect: 'freeze' },
            earth: { name: 'Stone Crash', icon: 'üåç', baseDamage: 40, cooldown: 3, effect: 'stun' },
            storm: { name: 'Thunder Strike', icon: '‚ö°', baseDamage: 45, cooldown: 3, effect: 'shock' },
            shadow: { name: 'Dark Void', icon: 'üåô', baseDamage: 25, cooldown: 2, effect: 'drain' }
        };

        // Equipment and clothing system for humanoids
        const equipmentData = {
            weapons: {
                sword: { name: 'Sword', icon: '‚öîÔ∏è', color: '#C0C0C0', damage: 5, rarity: 'common' },
                axe: { name: 'Battle Axe', icon: 'ü™ì', color: '#8B4513', damage: 8, rarity: 'common' },
                mace: { name: 'War Mace', icon: 'üî®', color: '#696969', damage: 6, rarity: 'common' },
                staff: { name: 'Magic Staff', icon: 'ü™Ñ', color: '#8A2BE2', damage: 4, rarity: 'uncommon' },
                bow: { name: 'Long Bow', icon: 'üèπ', color: '#8B4513', damage: 7, rarity: 'uncommon' },
                dagger: { name: 'Sharp Dagger', icon: 'üó°Ô∏è', color: '#C0C0C0', damage: 3, rarity: 'common' }
            },
            armor: {
                leather: { name: 'Leather Armor', color: '#8B4513', defense: 2, rarity: 'common' },
                chain: { name: 'Chain Mail', color: '#C0C0C0', defense: 4, rarity: 'uncommon' },
                plate: { name: 'Plate Armor', color: '#696969', defense: 6, rarity: 'rare' },
                robe: { name: 'Magic Robe', color: '#4B0082', defense: 1, rarity: 'uncommon' }
            },
            helmets: {
                cap: { name: 'Leather Cap', color: '#8B4513', defense: 1, rarity: 'common' },
                helmet: { name: 'Iron Helmet', color: '#696969', defense: 2, rarity: 'uncommon' },
                crown: { name: 'Royal Crown', color: '#FFD700', defense: 1, rarity: 'rare' },
                hood: { name: 'Magic Hood', color: '#4B0082', defense: 1, rarity: 'uncommon' }
            },
            accessories: {
                belt: { name: 'Utility Belt', color: '#654321' },
                cloak: { name: 'Travel Cloak', color: '#2F4F2F' },
                boots: { name: 'Sturdy Boots', color: '#8B4513' },
                gloves: { name: 'Work Gloves', color: '#654321' }
            }
        };

        // Inventory Management System
        function addItemToInventory(itemType, itemKey, quantity = 1) {
            if (itemType === 'equipment') {
                // Equipment items don't stack, add individually
                if (playerInventory.equipment.length < playerInventory.maxSlots) {
                    const equipmentItem = equipmentData[itemKey.category]?.[itemKey.key];
                    if (equipmentItem) {
                        playerInventory.equipment.push({ ...equipmentItem, key: itemKey.key, category: itemKey.category });
                        updateInventorySlots();
                        return true;
                    }
                }
                return false;
            } else if (itemType === 'consumables' && playerInventory.consumables.hasOwnProperty(itemKey)) {
                playerInventory.consumables[itemKey] += quantity;
                updateInventorySlots();
                return true;
            } else if (itemType === 'materials' && playerInventory.materials.hasOwnProperty(itemKey)) {
                playerInventory.materials[itemKey] += quantity;
                updateInventorySlots();
                return true;
            } else if (itemType === 'basic') {
                // Handle basic items (food, potions, wood, gold)
                if (playerInventory.hasOwnProperty(itemKey)) {
                    playerInventory[itemKey] += quantity;
                    return true;
                }
            }
            return false;
        }

        function removeItemFromInventory(itemType, itemKey, quantity = 1) {
            if (itemType === 'equipment') {
                const itemIndex = playerInventory.equipment.findIndex(item => 
                    item.key === itemKey.key && item.category === itemKey.category
                );
                if (itemIndex !== -1) {
                    playerInventory.equipment.splice(itemIndex, 1);
                    updateInventorySlots();
                    return true;
                }
            } else if (itemType === 'consumables' && playerInventory.consumables.hasOwnProperty(itemKey)) {
                if (playerInventory.consumables[itemKey] >= quantity) {
                    playerInventory.consumables[itemKey] -= quantity;
                    updateInventorySlots();
                    return true;
                }
            } else if (itemType === 'materials' && playerInventory.materials.hasOwnProperty(itemKey)) {
                if (playerInventory.materials[itemKey] >= quantity) {
                    playerInventory.materials[itemKey] -= quantity;
                    updateInventorySlots();
                    return true;
                }
            } else if (itemType === 'basic' && playerInventory.hasOwnProperty(itemKey)) {
                if (playerInventory[itemKey] >= quantity) {
                    playerInventory[itemKey] -= quantity;
                    return true;
                }
            }
            return false;
        }

        function updateInventorySlots() {
            let usedSlots = playerInventory.equipment.length;
            
            // Count non-zero consumables
            Object.values(playerInventory.consumables).forEach(count => {
                if (count > 0) usedSlots++;
            });
            
            // Count non-zero materials
            Object.values(playerInventory.materials).forEach(count => {
                if (count > 0) usedSlots++;
            });
            
            // Count key items
            usedSlots += playerInventory.keyItems.length;
            
            playerInventory.usedSlots = usedSlots;
        }

        function useConsumableItem(itemKey) {
            if (playerInventory.consumables[itemKey] > 0) {
                const item = consumableItems[itemKey];
                if (item && item.effect) {
                    // Apply effects to dragon
                    if (item.effect.happiness) {
                        dragonStats.happiness = Math.min(100, dragonStats.happiness + item.effect.happiness);
                    }
                    if (item.effect.hunger) {
                        dragonStats.hunger = Math.min(100, dragonStats.hunger + item.effect.hunger);
                    }
                    if (item.effect.health) {
                        dragonStats.health = Math.min(100, dragonStats.health + item.effect.health);
                    }
                    if (item.effect.experience) {
                        dragonStats.experience += item.effect.experience;
                        if (dragonStats.experience >= dragonStats.level * 100) {
                            dragonStats.level++;
                            dragonStats.experience = 0;
                            updateStatus(`${dragonStats.name} leveled up! Level ${dragonStats.level}! üéâ`);
                        }
                    }
                    
                    // Remove item from inventory
                    playerInventory.consumables[itemKey]--;
                    updateInventorySlots();
                    updateInventoryPanel();
                    updateDragonPanel();
                    
                    updateStatus(`Used ${item.name} on ${dragonStats.name}! ${item.icon}`);
                    return true;
                }
            }
            return false;
        }

        function getInventoryValue() {
            let totalValue = playerInventory.gold;
            
            // Add equipment values
            playerInventory.equipment.forEach(item => {
                totalValue += item.damage ? item.damage * 10 : 0;
                totalValue += item.defense ? item.defense * 15 : 0;
            });
            
            // Add consumable values
            Object.keys(playerInventory.consumables).forEach(key => {
                if (consumableItems[key]) {
                    totalValue += playerInventory.consumables[key] * consumableItems[key].value;
                }
            });
            
            // Add material values
            Object.keys(playerInventory.materials).forEach(key => {
                if (materialItems[key]) {
                    totalValue += playerInventory.materials[key] * materialItems[key].value;
                }
            });
            
            // Add basic item values
            totalValue += playerInventory.wood * 5;
            totalValue += playerInventory.food * 10;
            totalValue += playerInventory.potions * 20;
            
            return totalValue;
        }

        // Initialize the game
        window.addEventListener('load', function() {
            console.log('Game loading...');
            
            // Disable all browser interference
            disableBrowserInterference();
            
            // Try to go fullscreen
            requestFullscreen();
            
            initPixiJS();
            generateDragonTraits();
            
            // Create background elements first
            createFantasyBackground(); 
            createWorldFeatures();
            createEnvironmentalDetails();
            
            // Then create entities on top
            createPlayerSprite();
            createDragonSprite();
            createWorldObjects();
            createWanderingDragons();
            initializeMiniMap();
            centerCamera();
            
            // Set up movement controls
            setupControls();
            
            // Initialize UI panels
            updateDragonPanel();
            updateInventoryPanel();
            
            console.log('Game loaded successfully!');
            updateStatus('Game loaded! Use WASD to move, click objects to interact.');
        });
        
        function disableBrowserInterference() {
            // Prevent zoom gestures
            document.addEventListener('gesturestart', e => e.preventDefault());
            document.addEventListener('gesturechange', e => e.preventDefault());
            document.addEventListener('gestureend', e => e.preventDefault());
            
            // Prevent pinch zoom
            document.addEventListener('touchstart', function(event) {
                if (event.touches.length > 1) {
                    event.preventDefault();
                }
            }, { passive: false });
            
            // Prevent double tap zoom
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
            
            // Prevent pull-to-refresh
            document.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Prevent context menu
            document.addEventListener('contextmenu', e => e.preventDefault());
            
            // Prevent keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                // Allow game controls but prevent browser shortcuts
                const allowedKeys = ['KeyW', 'KeyA', 'KeyS', 'KeyD', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
                if (!allowedKeys.includes(e.code) && (e.ctrlKey || e.metaKey || e.altKey)) {
                    e.preventDefault();
                }
                
                // Prevent F5, F11, etc.
                if (e.key.startsWith('F') || e.key === 'Escape') {
                    e.preventDefault();
                }
            });
            
            // Prevent scrolling
            document.addEventListener('wheel', e => e.preventDefault(), { passive: false });
            document.addEventListener('scroll', e => e.preventDefault(), { passive: false });
        }
        
        function requestFullscreen() {
            const elem = document.documentElement;
            
            // Add click handler to enter fullscreen
            document.addEventListener('click', function enterFullscreen() {
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                }
                
                // Remove the event listener after first click
                document.removeEventListener('click', enterFullscreen);
            }, { once: true });
            
            // Auto-request fullscreen on mobile
            if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                setTimeout(() => {
                    if (document.documentElement.requestFullscreen) {
                        document.documentElement.requestFullscreen();
                    }
                }, 1000);
            }
        }

        function initPixiJS() {
            const worldContainer = document.getElementById('worldContainer');
            
            // Create PixiJS application
            pixiApp = new PIXI.Application({
                width: 2000,
                height: 1500,
                backgroundColor: 0x87ceeb,
                antialias: true
            });

            // Add canvas to world container
            worldContainer.appendChild(pixiApp.view);
            pixiApp.view.className = 'pixi-canvas';

            // Create main container for sprites
            pixiContainer = new PIXI.Container();
            pixiApp.stage.addChild(pixiContainer);
            
            // Create separate containers for layering
            backgroundContainer = new PIXI.Container(); // For background elements
            entityContainer = new PIXI.Container(); // For players, dragons, monsters
            
            // Enable sorting on containers
            backgroundContainer.sortableChildren = true;
            entityContainer.sortableChildren = true;
            
            // Add containers in proper order (background first, entities on top)
            backgroundContainer.zIndex = 0;
            entityContainer.zIndex = 1;
            
            pixiContainer.addChild(backgroundContainer);
            pixiContainer.addChild(entityContainer);
            
            // Enable sorting for proper layering
            pixiContainer.sortableChildren = true;

            console.log('PixiJS initialized with proper layering');
        }

        function createPlayerSprite() {
            if (!pixiApp || !entityContainer) return;

            // Create player graphics container
            const playerContainer = new PIXI.Container();
            
            // Player head
            const head = new PIXI.Graphics();
            head.beginFill(0xFFDBAE); // Skin tone
            head.drawCircle(0, -18, 8);
            head.endFill();
            
            // Player hair
            const hair = new PIXI.Graphics();
            hair.beginFill(0x8B4513); // Brown hair
            hair.drawCircle(0, -20, 10);
            hair.endFill();
            
            // Player body (torso)
            const body = new PIXI.Graphics();
            body.beginFill(0x228B22); // Green shirt
            body.drawRoundedRect(-8, -10, 16, 18, 3);
            body.endFill();
            
            // Player legs
            const legs = new PIXI.Graphics();
            legs.beginFill(0x000080); // Dark blue pants
            legs.drawRoundedRect(-6, 8, 12, 12, 2);
            legs.endFill();
            
            // Player feet
            const feet = new PIXI.Graphics();
            feet.beginFill(0x654321); // Brown shoes
            feet.drawEllipse(-4, 22, 3, 2);
            feet.drawEllipse(4, 22, 3, 2);
            feet.endFill();
            
            // Arms
            const leftArm = new PIXI.Graphics();
            leftArm.beginFill(0xFFDBAE); // Skin tone
            leftArm.drawRoundedRect(-12, -8, 4, 14, 2);
            leftArm.endFill();
            
            const rightArm = new PIXI.Graphics();
            rightArm.beginFill(0xFFDBAE); // Skin tone
            rightArm.drawRoundedRect(8, -8, 4, 14, 2);
            rightArm.endFill();
            
            // Eyes (facing direction)
            const eyes = new PIXI.Graphics();
            eyes.beginFill(0x000000); // Black eyes
            eyes.drawCircle(-3, -18, 1.5);
            eyes.drawCircle(3, -18, 1.5);
            eyes.endFill();
            
            // Add outline/border
            const outline = new PIXI.Graphics();
            outline.lineStyle(1, 0x000000, 0.3);
            outline.drawCircle(0, -18, 8); // Head outline
            outline.drawRoundedRect(-8, -10, 16, 18, 3); // Body outline
            outline.drawRoundedRect(-6, 8, 12, 12, 2); // Legs outline
            outline.lineStyle(0);
            
            // Assemble player sprite
            playerContainer.addChild(hair);
            playerContainer.addChild(head);
            playerContainer.addChild(leftArm);
            playerContainer.addChild(rightArm);
            playerContainer.addChild(body);
            playerContainer.addChild(legs);
            playerContainer.addChild(feet);
            playerContainer.addChild(eyes);
            playerContainer.addChild(outline);
            
            // Position player
            playerContainer.x = playerPosition.x;
            playerContainer.y = 1500 - playerPosition.y; // Flip Y coordinate
            
            // Store references for animation
            playerContainer.bodyParts = {
                head, hair, body, legs, feet, leftArm, rightArm, eyes, outline
            };

            playerSprite = playerContainer;
            playerSprite.zIndex = 100; // Ensure player is on top
            entityContainer.addChild(playerSprite);
            
            console.log('Enhanced player sprite created at:', playerPosition.x, playerPosition.y);
        }
        
        function generateDragonTraits() {
            // Dragon types with associated traits
            const types = [
                {
                    name: 'fire',
                    bodyColors: [0xFF4444, 0xFF6600, 0xDD2222],
                    accentColors: [0xFF8800, 0xFFAA00, 0xFF2200],
                    eyeColors: [0xFF0000, 0xFF4400, 0xFFFF00],
                    wingChance: 0.8,
                    hornChance: 0.9,
                    tailTypes: ['spiked', 'flame', 'barbed']
                },
                {
                    name: 'ice',
                    bodyColors: [0x4444FF, 0x6699FF, 0x88CCFF],
                    accentColors: [0xAADDFF, 0xCCEEFF, 0x99BBFF],
                    eyeColors: [0x0088FF, 0x44AAFF, 0xAADDFF],
                    wingChance: 0.7,
                    hornChance: 0.6,
                    tailTypes: ['icicle', 'smooth', 'crystalline']
                },
                {
                    name: 'earth',
                    bodyColors: [0x8B4513, 0x654321, 0xA0522D],
                    accentColors: [0x228B22, 0x32CD32, 0x90EE90],
                    eyeColors: [0x8B4513, 0x228B22, 0x90EE90],
                    wingChance: 0.4,
                    hornChance: 0.8,
                    tailTypes: ['club', 'thick', 'rocky']
                },
                {
                    name: 'storm',
                    bodyColors: [0x708090, 0x2F4F4F, 0x696969],
                    accentColors: [0xFFFF00, 0xFFD700, 0xFFFACD],
                    eyeColors: [0xFFFF00, 0x00FFFF, 0xFFFFFF],
                    wingChance: 0.95,
                    hornChance: 0.7,
                    tailTypes: ['lightning', 'forked', 'electric']
                },
                {
                    name: 'shadow',
                    bodyColors: [0x2F2F2F, 0x1C1C1C, 0x444444],
                    accentColors: [0x8B008B, 0x4B0082, 0x663399],
                    eyeColors: [0x8B008B, 0xFF00FF, 0x9400D3],
                    wingChance: 0.6,
                    hornChance: 0.5,
                    tailTypes: ['wispy', 'ethereal', 'curved']
                }
            ];
            
            const personalities = ['friendly', 'fierce', 'playful', 'wise', 'mischievous'];
            
            // Select random type
            const selectedType = types[Math.floor(Math.random() * types.length)];
            dragonStats.type = selectedType.name;
            
            // Generate traits based on type
            dragonStats.traits.hasWings = Math.random() < selectedType.wingChance;
            dragonStats.traits.hasHorns = Math.random() < selectedType.hornChance;
            dragonStats.traits.tailType = selectedType.tailTypes[Math.floor(Math.random() * selectedType.tailTypes.length)];
            dragonStats.traits.bodyColor = selectedType.bodyColors[Math.floor(Math.random() * selectedType.bodyColors.length)];
            dragonStats.traits.accentColor = selectedType.accentColors[Math.floor(Math.random() * selectedType.accentColors.length)];
            dragonStats.traits.eyeColor = selectedType.eyeColors[Math.floor(Math.random() * selectedType.eyeColors.length)];
            
            // Random personality
            dragonStats.personality = personalities[Math.floor(Math.random() * personalities.length)];
            
            // Size based on level
            dragonStats.traits.size = 0.5 + (dragonStats.level * 0.1);
            
            // Initialize position near player
            dragonStats.position.x = playerPosition.x + 50;
            dragonStats.position.y = playerPosition.y;
            dragonStats.targetPosition.x = dragonStats.position.x;
            dragonStats.targetPosition.y = dragonStats.position.y;
            
            console.log('Generated dragon:', dragonStats.type, dragonStats.personality, dragonStats.traits);
        }
        
        function createDragonSprite() {
            if (!pixiApp || !entityContainer) return;
            
            // Create dragon container
            const dragonContainer = new PIXI.Container();
            const scale = dragonStats.traits.size;
            
            // Dragon body (main torso)
            const body = new PIXI.Graphics();
            body.beginFill(dragonStats.traits.bodyColor);
            body.drawEllipse(0, 0, 25 * scale, 15 * scale);
            body.endFill();
            
            // Dragon head
            const head = new PIXI.Graphics();
            head.beginFill(dragonStats.traits.bodyColor);
            head.drawEllipse(-20 * scale, -5 * scale, 15 * scale, 12 * scale);
            head.endFill();
            
            // Dragon tail
            const tail = new PIXI.Graphics();
            tail.beginFill(dragonStats.traits.bodyColor);
            if (dragonStats.traits.tailType === 'spiked' || dragonStats.traits.tailType === 'barbed') {
                // Spiked tail
                tail.moveTo(20 * scale, 0);
                tail.lineTo(35 * scale, -5 * scale);
                tail.lineTo(40 * scale, 0);
                tail.lineTo(35 * scale, 5 * scale);
                tail.closePath();
            } else if (dragonStats.traits.tailType.includes('smooth') || dragonStats.traits.tailType.includes('wispy')) {
                // Smooth/wispy tail
                tail.drawEllipse(30 * scale, 0, 12 * scale, 6 * scale);
            } else {
                // Default thick tail
                tail.drawEllipse(28 * scale, 0, 15 * scale, 8 * scale);
            }
            tail.endFill();
            
            // Dragon wings (if has wings)
            let leftWing = null, rightWing = null;
            if (dragonStats.traits.hasWings) {
                leftWing = new PIXI.Graphics();
                leftWing.beginFill(dragonStats.traits.accentColor);
                leftWing.moveTo(-10 * scale, -10 * scale);
                leftWing.lineTo(-25 * scale, -20 * scale);
                leftWing.lineTo(-15 * scale, -35 * scale);
                leftWing.lineTo(0, -25 * scale);
                leftWing.closePath();
                leftWing.endFill();
                
                rightWing = new PIXI.Graphics();
                rightWing.beginFill(dragonStats.traits.accentColor);
                rightWing.moveTo(10 * scale, -10 * scale);
                rightWing.lineTo(25 * scale, -20 * scale);
                rightWing.lineTo(15 * scale, -35 * scale);
                rightWing.lineTo(0, -25 * scale);
                rightWing.closePath();
                rightWing.endFill();
            }
            
            // Dragon horns (if has horns)
            let leftHorn = null, rightHorn = null;
            if (dragonStats.traits.hasHorns) {
                leftHorn = new PIXI.Graphics();
                leftHorn.beginFill(dragonStats.traits.accentColor);
                leftHorn.moveTo(-25 * scale, -8 * scale);
                leftHorn.lineTo(-30 * scale, -18 * scale);
                leftHorn.lineTo(-22 * scale, -15 * scale);
                leftHorn.closePath();
                leftHorn.endFill();
                
                rightHorn = new PIXI.Graphics();
                rightHorn.beginFill(dragonStats.traits.accentColor);
                rightHorn.moveTo(-15 * scale, -8 * scale);
                rightHorn.lineTo(-20 * scale, -18 * scale);
                rightHorn.lineTo(-12 * scale, -15 * scale);
                rightHorn.closePath();
                rightHorn.endFill();
            }
            
            // Dragon legs
            const leg1 = new PIXI.Graphics();
            leg1.beginFill(dragonStats.traits.bodyColor);
            leg1.drawEllipse(-15 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg1.endFill();
            
            const leg2 = new PIXI.Graphics();
            leg2.beginFill(dragonStats.traits.bodyColor);
            leg2.drawEllipse(-5 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg2.endFill();
            
            const leg3 = new PIXI.Graphics();
            leg3.beginFill(dragonStats.traits.bodyColor);
            leg3.drawEllipse(5 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg3.endFill();
            
            const leg4 = new PIXI.Graphics();
            leg4.beginFill(dragonStats.traits.bodyColor);
            leg4.drawEllipse(15 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg4.endFill();
            
            // Dragon eyes
            const eyes = new PIXI.Graphics();
            eyes.beginFill(dragonStats.traits.eyeColor);
            eyes.drawCircle(-25 * scale, -8 * scale, 2 * scale);
            eyes.drawCircle(-20 * scale, -8 * scale, 2 * scale);
            eyes.endFill();
            
            // Assemble dragon sprite
            dragonContainer.addChild(tail);
            dragonContainer.addChild(leg1);
            dragonContainer.addChild(leg2);
            dragonContainer.addChild(leg3);
            dragonContainer.addChild(leg4);
            dragonContainer.addChild(body);
            dragonContainer.addChild(head);
            
            if (leftWing && rightWing) {
                dragonContainer.addChild(leftWing);
                dragonContainer.addChild(rightWing);
            }
            
            if (leftHorn && rightHorn) {
                dragonContainer.addChild(leftHorn);
                dragonContainer.addChild(rightHorn);
            }
            
            dragonContainer.addChild(eyes);
            
            // Position dragon
            dragonContainer.x = dragonStats.position.x;
            dragonContainer.y = 1500 - dragonStats.position.y;
            
            // Store references for animation
            dragonContainer.bodyParts = {
                body, head, tail, eyes, legs: [leg1, leg2, leg3, leg4],
                wings: leftWing && rightWing ? [leftWing, rightWing] : null,
                horns: leftHorn && rightHorn ? [leftHorn, rightHorn] : null
            };
            
            dragonSprite = dragonContainer;
            entityContainer.addChild(dragonSprite);
            
            console.log('Dragon sprite created:', dragonStats.type, 'at', dragonStats.position.x, dragonStats.position.y);
        }
        
        function updateDragon() {
            if (!dragonSprite || !dragonStats) return;
            
            // Update dragon AI based on personality
            updateDragonAI();
            
            // Update dragon position (following behavior)
            updateDragonPosition();
            
            // Update dragon animations
            updateDragonAnimations();
            
            // Update dragon emotions based on stats
            updateDragonEmotion();
        }
        
        function updateDragonAI() {
            // Calculate distance from player
            const dx = playerPosition.x - dragonStats.position.x;
            const dy = playerPosition.y - dragonStats.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Dragon behavior based on personality and stats
            let followDistance = 60; // Base follow distance
            let speed = 2; // Base movement speed
            
            switch(dragonStats.personality) {
                case 'friendly':
                    followDistance = 40; // Stays close
                    speed = 2.5;
                    break;
                case 'fierce':
                    followDistance = 80; // Keeps some distance
                    speed = 3;
                    if (battleState.inBattle) {
                        followDistance = 30; // Gets closer during battle
                        speed = 4;
                    }
                    break;
                case 'playful':
                    followDistance = 50 + Math.sin(Date.now() * 0.002) * 20; // Varies distance playfully
                    speed = 2 + Math.sin(Date.now() * 0.003) * 1;
                    break;
                case 'wise':
                    followDistance = 70; // Maintains respectful distance
                    speed = 1.8; // Moves deliberately
                    break;
                case 'mischievous':
                    followDistance = 45 + Math.sin(Date.now() * 0.004) * 25; // Erratic following
                    speed = 2.2;
                    // Occasionally wanders randomly
                    if (Math.random() < 0.005) {
                        dragonStats.targetPosition.x += (Math.random() - 0.5) * 100;
                        dragonStats.targetPosition.y += (Math.random() - 0.5) * 100;
                    }
                    break;
            }
            
            // Adjust behavior based on dragon stats
            if (dragonStats.happiness < 30) {
                followDistance += 20; // Stays further when unhappy
                speed *= 0.8;
            } else if (dragonStats.happiness > 80) {
                followDistance -= 10; // Gets closer when happy
                speed *= 1.1;
            }
            
            if (dragonStats.hunger < 20) {
                speed *= 0.6; // Moves slower when hungry
            }
            
            if (dragonStats.health < 40) {
                followDistance += 30; // Stays further when injured
                speed *= 0.7;
            }
            
            // Set target position based on follow distance
            if (distance > followDistance) {
                const angle = Math.atan2(dy, dx);
                dragonStats.targetPosition.x = playerPosition.x - Math.cos(angle) * followDistance;
                dragonStats.targetPosition.y = playerPosition.y - Math.sin(angle) * followDistance;
            }
            
            // Keep dragon within world bounds
            dragonStats.targetPosition.x = Math.max(50, Math.min(1950, dragonStats.targetPosition.x));
            dragonStats.targetPosition.y = Math.max(50, Math.min(1450, dragonStats.targetPosition.y));
        }
        
        function updateDragonPosition() {
            // Smooth movement towards target
            const dx = dragonStats.targetPosition.x - dragonStats.position.x;
            const dy = dragonStats.targetPosition.y - dragonStats.position.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 5) {
                const moveSpeed = Math.min(distance * 0.1, 3);
                const angle = Math.atan2(dy, dx);
                
                dragonStats.position.x += Math.cos(angle) * moveSpeed;
                dragonStats.position.y += Math.sin(angle) * moveSpeed;
                
                // Update sprite position
                dragonSprite.x = dragonStats.position.x;
                dragonSprite.y = 1500 - dragonStats.position.y;
                
                // Face movement direction properly (flipped)
                // dx > 0 means moving right, so face left (flip X)
                // dx < 0 means moving left, so face right (normal X)
                if (Math.abs(dx) > 2) { // Only change direction if moving significantly
                    if (dx > 0) {
                        dragonSprite.scale.x = -Math.abs(dragonSprite.scale.x); // Face left when moving right (flipped)
                    } else {
                        dragonSprite.scale.x = Math.abs(dragonSprite.scale.x); // Face right when moving left (normal)
                    }
                }
            }
        }
        
        function updateDragonAnimations() {
            if (!dragonSprite.bodyParts) return;
            
            const time = Date.now() * 0.001;
            
            // Breathing animation (body scale)
            const breathScale = 1 + Math.sin(time * 2) * 0.05;
            dragonSprite.bodyParts.body.scale.y = breathScale;
            
            // Wing flapping (if has wings)
            if (dragonSprite.bodyParts.wings) {
                const wingFlap = Math.sin(time * 4) * 0.2;
                dragonSprite.bodyParts.wings[0].rotation = -0.2 + wingFlap;
                dragonSprite.bodyParts.wings[1].rotation = 0.2 - wingFlap;
                
                // Fly slightly up and down
                const flyBob = Math.sin(time * 3) * 3;
                dragonSprite.y += flyBob * 0.1;
            }
            
            // Tail sway
            const tailSway = Math.sin(time * 1.5) * 0.3;
            dragonSprite.bodyParts.tail.rotation = tailSway;
            
            // Eye blink
            dragonStats.animations.idle.timer += 1;
            if (dragonStats.animations.idle.timer > 180) { // Blink every ~3 seconds
                dragonStats.animations.idle.timer = 0;
                dragonSprite.bodyParts.eyes.alpha = 0.3;
                setTimeout(() => {
                    if (dragonSprite.bodyParts.eyes) {
                        dragonSprite.bodyParts.eyes.alpha = 1;
                    }
                }, 150);
            }
            
            // Leg animation when moving
            const dx = dragonStats.targetPosition.x - dragonStats.position.x;
            const dy = dragonStats.targetPosition.y - dragonStats.position.y;
            const isMoving = Math.sqrt(dx * dx + dy * dy) > 5;
            
            if (isMoving) {
                const legBob = Math.sin(time * 6) * 0.1;
                dragonSprite.bodyParts.legs[0].y += legBob;
                dragonSprite.bodyParts.legs[2].y += legBob;
                dragonSprite.bodyParts.legs[1].y -= legBob;
                dragonSprite.bodyParts.legs[3].y -= legBob;
            }
        }
        
        function updateDragonEmotion() {
            if (!dragonSprite.bodyParts) return;
            
            // Change dragon emotion based on stats
            let newEmotion = 'neutral';
            
            if (dragonStats.happiness > 80) {
                newEmotion = 'happy';
            } else if (dragonStats.happiness < 30) {
                newEmotion = 'sad';
            } else if (dragonStats.health < 30) {
                newEmotion = 'hurt';
            } else if (dragonStats.hunger < 20) {
                newEmotion = 'hungry';
            } else if (battleState.inBattle) {
                newEmotion = 'angry';
            }
            
            if (newEmotion !== dragonStats.animations.emotion) {
                dragonStats.animations.emotion = newEmotion;
                
                // Update eye color based on emotion
                dragonSprite.bodyParts.eyes.clear();
                dragonSprite.bodyParts.eyes.beginFill(getEmotionEyeColor(newEmotion));
                const scale = dragonStats.traits.size;
                dragonSprite.bodyParts.eyes.drawCircle(-25 * scale, -8 * scale, 2 * scale);
                dragonSprite.bodyParts.eyes.drawCircle(-20 * scale, -8 * scale, 2 * scale);
                dragonSprite.bodyParts.eyes.endFill();
            }
        }
        
        function getEmotionEyeColor(emotion) {
            switch(emotion) {
                case 'happy': return 0x00FF00; // Green
                case 'sad': return 0x4444FF; // Blue
                case 'hurt': return 0xFF4444; // Red
                case 'hungry': return 0xFFAA00; // Orange
                case 'angry': return 0xFF0000; // Bright red
                default: return dragonStats.traits.eyeColor; // Original color
            }
        }

        function createFantasyBackground() {
            if (!pixiApp || !backgroundContainer) return;
            
            // Create a simple, subtle fantasy background
            
            // Subtle gradient background
            const background = new PIXI.Graphics();
            
            // Sky gradient - subtle
            background.beginFill(0x87CEEB, 0.3); // Very light sky blue
            background.drawRect(0, 0, 2000, 1500);
            background.endFill();
            
            // Distant mountains - very subtle
            const mountains = new PIXI.Graphics();
            mountains.beginFill(0x9090A0, 0.2); // Very faint gray mountains
            mountains.moveTo(0, 600);
            mountains.lineTo(300, 400);
            mountains.lineTo(600, 500);
            mountains.lineTo(900, 350);
            mountains.lineTo(1200, 450);
            mountains.lineTo(1500, 380);
            mountains.lineTo(1800, 480);
            mountains.lineTo(2000, 420);
            mountains.lineTo(2000, 600);
            mountains.closePath();
            mountains.endFill();
            
            // Subtle grass texture
            const grass = new PIXI.Graphics();
            grass.beginFill(0x90EE90, 0.15); // Very light green overlay
            grass.drawRect(0, 600, 2000, 900);
            grass.endFill();
            
            // Some subtle grass patches for texture
            grass.beginFill(0x98FB98, 0.1);
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 2000;
                const y = 600 + Math.random() * 900;
                const size = 40 + Math.random() * 80;
                grass.drawCircle(x, y, size);
            }
            grass.endFill();
            
            // Simple dirt path - draw as separate segments to avoid overlap issues
            const paths = new PIXI.Graphics();
            paths.beginFill(0xD2B48C, 0.15); // Even more transparent
            // Draw paths in segments to avoid full coverage
            paths.drawRect(950, 0, 100, 600); // Top segment of vertical road
            paths.drawRect(950, 900, 100, 600); // Bottom segment of vertical road  
            paths.drawRect(0, 745, 900, 60); // Left segment of horizontal road
            paths.drawRect(1100, 745, 900, 60); // Right segment of horizontal road
            // Center crossroads
            paths.beginFill(0xD2B48C, 0.2);
            paths.drawRect(950, 745, 100, 60); // Crossroads center
            paths.endFill();
            
            // Add to background container in correct order
            backgroundContainer.addChild(background);
            backgroundContainer.addChild(mountains);
            backgroundContainer.addChild(grass);
            backgroundContainer.addChild(paths);
            
            console.log('Subtle fantasy background created');
        }

        function createWorldFeatures() {
            if (!backgroundContainer) return;
            
            // Create a small pond/lake - subtle
            const pond = new PIXI.Graphics();
            pond.beginFill(0x4682B4, 0.4); // Subtle steel blue water
            pond.drawEllipse(1500, 1500 - 1100, 80, 60);
            pond.endFill();
            pond.beginFill(0x87CEEB, 0.2); // Very light blue surface
            pond.drawEllipse(1500, 1500 - 1100, 70, 50);
            pond.endFill();
            backgroundContainer.addChild(pond);
            
            // Create a small stream - subtle
            const stream = new PIXI.Graphics();
            stream.lineStyle(4, 0x4682B4, 0.3);
            stream.moveTo(1500, 1500 - 1040); // From pond
            stream.bezierCurveTo(1400, 1500 - 900, 1200, 1500 - 800, 1000, 1500 - 700);
            backgroundContainer.addChild(stream);
            
            // Add scattered rocks
            const rockPositions = [
                {x: 600, y: 700}, {x: 1400, y: 650}, {x: 800, y: 1200}, 
                {x: 1600, y: 800}, {x: 400, y: 900}, {x: 1800, y: 1000}
            ];
            
            rockPositions.forEach(pos => {
                const rock = new PIXI.Graphics();
                const size = 0.5 + Math.random() * 0.8;
                const grayShade = 0x696969 + Math.floor(Math.random() * 0x202020);
                
                rock.beginFill(grayShade);
                rock.drawEllipse(0, 0, 15 * size, 12 * size);
                rock.endFill();
                rock.beginFill(grayShade + 0x101010);
                rock.drawEllipse(-3 * size, -2 * size, 8 * size, 6 * size);
                rock.endFill();
                
                rock.x = pos.x;
                rock.y = 1500 - pos.y;
                backgroundContainer.addChild(rock);
            });
            
            // Add flower patches
            const flowerPatches = [
                {x: 700, y: 850, color: 0xFF69B4, count: 8}, // Pink flowers
                {x: 1200, y: 950, color: 0xFF4500, count: 6}, // Orange flowers  
                {x: 1400, y: 750, color: 0x9370DB, count: 7}, // Purple flowers
                {x: 900, y: 1100, color: 0xFFD700, count: 5}, // Yellow flowers
            ];
            
            flowerPatches.forEach(patch => {
                for (let i = 0; i < patch.count; i++) {
                    const flower = new PIXI.Graphics();
                    const offsetX = (Math.random() - 0.5) * 40;
                    const offsetY = (Math.random() - 0.5) * 40;
                    
                    // Flower petals
                    flower.beginFill(patch.color);
                    for (let petal = 0; petal < 5; petal++) {
                        const angle = (petal * Math.PI * 2) / 5;
                        const petalX = Math.cos(angle) * 3;
                        const petalY = Math.sin(angle) * 3;
                        flower.drawCircle(petalX, petalY, 2);
                    }
                    flower.endFill();
                    
                    // Flower center
                    flower.beginFill(0xFFFF00);
                    flower.drawCircle(0, 0, 1.5);
                    flower.endFill();
                    
                    // Stem
                    flower.lineStyle(1, 0x228B22);
                    flower.moveTo(0, 0);
                    flower.lineTo(0, 8);
                    
                    flower.x = patch.x + offsetX;
                    flower.y = 1500 - (patch.y + offsetY);
                    backgroundContainer.addChild(flower);
                }
            });
            
            console.log('World features created');
        }

        function createEnvironmentalDetails() {
            if (!backgroundContainer) return;
            
            // Add mushroom rings
            const mushroomRings = [
                {x: 650, y: 1050, radius: 25},
                {x: 1350, y: 850, radius: 30}
            ];
            
            mushroomRings.forEach(ring => {
                const mushroomCount = 8 + Math.floor(Math.random() * 4);
                for (let i = 0; i < mushroomCount; i++) {
                    const mushroom = new PIXI.Graphics();
                    const angle = (i * Math.PI * 2) / mushroomCount;
                    const mushroomX = ring.x + Math.cos(angle) * ring.radius;
                    const mushroomY = ring.y + Math.sin(angle) * ring.radius;
                    
                    // Mushroom stem
                    mushroom.beginFill(0xF5DEB3);
                    mushroom.drawRect(-1, -2, 2, 4);
                    mushroom.endFill();
                    
                    // Mushroom cap
                    mushroom.beginFill(0xDC143C);
                    mushroom.drawEllipse(0, -2, 3, 2);
                    mushroom.endFill();
                    
                    // Spots on cap
                    mushroom.beginFill(0xFFFFFF);
                    mushroom.drawCircle(-1, -2, 0.5);
                    mushroom.drawCircle(1, -2, 0.3);
                    mushroom.endFill();
                    
                    mushroom.x = mushroomX;
                    mushroom.y = 1500 - mushroomY;
                    backgroundContainer.addChild(mushroom);
                }
            });
            
            // Add ancient stone circle
            const stoneCircle = {x: 1600, y: 1200, radius: 40};
            const stoneCount = 8;
            
            for (let i = 0; i < stoneCount; i++) {
                const stone = new PIXI.Graphics();
                const angle = (i * Math.PI * 2) / stoneCount;
                const stoneX = stoneCircle.x + Math.cos(angle) * stoneCircle.radius;
                const stoneY = stoneCircle.y + Math.sin(angle) * stoneCircle.radius;
                const height = 15 + Math.random() * 10;
                
                stone.beginFill(0x708090); // Slate gray
                stone.drawRect(-3, -height, 6, height);
                stone.endFill();
                
                // Moss on stones
                stone.beginFill(0x228B22, 0.6);
                stone.drawRect(-2, -height/2, 4, height/3);
                stone.endFill();
                
                stone.x = stoneX;
                stone.y = 1500 - stoneY;
                backgroundContainer.addChild(stone);
            }
            
            // Add scattered bushes
            const bushPositions = [
                {x: 500, y: 800}, {x: 750, y: 1150}, {x: 1150, y: 650},
                {x: 1450, y: 900}, {x: 1700, y: 1100}
            ];
            
            bushPositions.forEach(pos => {
                const bush = new PIXI.Graphics();
                const bushSize = 0.6 + Math.random() * 0.8;
                
                // Bush foliage - multiple circles for natural look
                bush.beginFill(0x2E8B57); // Sea green
                bush.drawCircle(0, 0, 8 * bushSize);
                bush.drawCircle(-4 * bushSize, -2 * bushSize, 6 * bushSize);
                bush.drawCircle(4 * bushSize, -3 * bushSize, 5 * bushSize);
                bush.endFill();
                
                // Highlight
                bush.beginFill(0x3CB371, 0.7);
                bush.drawCircle(-2 * bushSize, -4 * bushSize, 4 * bushSize);
                bush.endFill();
                
                bush.x = pos.x;
                bush.y = 1500 - pos.y;
                backgroundContainer.addChild(bush);
            });
            
            console.log('Environmental details created');
        }

        function createWorldObjects() {
            if (!backgroundContainer) return;

            // Clear existing objects
            worldObjects.trees = [];
            worldObjects.sheep = [];
            worldObjects.structures = [];
            worldObjects.monsters = [];

            // Create trees with tracking
            const treePositions = [
                {x: 800, y: 800}, {x: 1200, y: 800}, {x: 1000, y: 1000},
                {x: 600, y: 600}, {x: 1400, y: 600}, {x: 500, y: 900},
                {x: 300, y: 1200}, {x: 1700, y: 1200}, {x: 1500, y: 400}
            ];

            treePositions.forEach((pos, index) => {
                const tree = new PIXI.Graphics();
                
                // Randomize tree appearance
                const treeVariation = index % 3;
                const scale = 0.8 + Math.random() * 0.4;
                
                // Tree trunk - varied colors and sizes
                const trunkColors = [0x8B4513, 0x654321, 0xA0522D];
                tree.beginFill(trunkColors[index % trunkColors.length]);
                tree.drawRect(-4 * scale, -20 * scale, 8 * scale, 20 * scale);
                tree.endFill();
                
                // Tree base (roots)
                tree.beginFill(0x654321);
                tree.drawEllipse(0, -2 * scale, 6 * scale, 3 * scale);
                tree.endFill();
                
                if (treeVariation === 0) {
                    // Oak tree - large round crown
                    tree.beginFill(0x228B22);
                    tree.drawCircle(0, -30 * scale, 18 * scale);
                    tree.endFill();
                    tree.beginFill(0x32CD32);
                    tree.drawCircle(-5 * scale, -25 * scale, 12 * scale);
                    tree.drawCircle(5 * scale, -25 * scale, 12 * scale);
                    tree.endFill();
                } else if (treeVariation === 1) {
                    // Pine tree - triangular
                    tree.beginFill(0x006400);
                    tree.moveTo(0, -45 * scale);
                    tree.lineTo(-15 * scale, -15 * scale);
                    tree.lineTo(15 * scale, -15 * scale);
                    tree.closePath();
                    tree.endFill();
                    tree.beginFill(0x228B22);
                    tree.moveTo(0, -35 * scale);
                    tree.lineTo(-12 * scale, -10 * scale);
                    tree.lineTo(12 * scale, -10 * scale);
                    tree.closePath();
                    tree.endFill();
                } else {
                    // Deciduous tree - irregular crown
                    tree.beginFill(0x32CD32);
                    tree.drawEllipse(-8 * scale, -35 * scale, 12 * scale, 15 * scale);
                    tree.drawEllipse(8 * scale, -30 * scale, 10 * scale, 12 * scale);
                    tree.drawEllipse(0, -40 * scale, 14 * scale, 18 * scale);
                    tree.endFill();
                    tree.beginFill(0x228B22);
                    tree.drawCircle(0, -30 * scale, 8 * scale);
                    tree.endFill();
                }
                
                tree.x = pos.x;
                tree.y = 1500 - pos.y; // Flip Y coordinate
                tree.interactive = true;
                tree.buttonMode = true;
                
                // Store tree data
                worldObjects.trees.push({
                    sprite: tree,
                    x: pos.x,
                    y: pos.y,
                    type: 'tree'
                });
                
                backgroundContainer.addChild(tree);
            });
            
            // Create sheep
            const sheepPositions = [
                {x: 900, y: 700}, {x: 1100, y: 900}, {x: 700, y: 1000}
            ];
            
            sheepPositions.forEach(pos => {
                const sheep = new PIXI.Graphics();
                
                // Sheep body
                sheep.beginFill(0xFFFFFF);
                sheep.drawEllipse(0, 0, 20, 15);
                sheep.endFill();
                
                // Sheep head
                sheep.beginFill(0x333333);
                sheep.drawCircle(-15, 0, 8);
                sheep.endFill();
                
                sheep.x = pos.x;
                sheep.y = 1500 - pos.y;
                sheep.interactive = true;
                sheep.buttonMode = true;
                
                // Store sheep data
                worldObjects.sheep.push({
                    sprite: sheep,
                    x: pos.x,
                    y: pos.y,
                    type: 'sheep',
                    animations: {
                        state: 'idle', // idle, grazing, walking
                        timer: Math.random() * 300,
                        direction: Math.random() * Math.PI * 2,
                        speed: 0.5 + Math.random() * 0.5,
                        homeX: pos.x,
                        homeY: pos.y,
                        wanderRadius: 50 + Math.random() * 30
                    }
                });
                
                entityContainer.addChild(sheep);
            });
            
            // Create structures
            const structurePositions = [
                {x: 1000, y: 750, type: 'house'}, 
                {x: 1300, y: 1000, type: 'cave'}
            ];
            
            structurePositions.forEach(pos => {
                const structure = new PIXI.Graphics();
                
                if (pos.type === 'house') {
                    // House base
                    structure.beginFill(0xCD853F);
                    structure.drawRect(-25, -20, 50, 40);
                    structure.endFill();
                    
                    // Roof
                    structure.beginFill(0x8B4513);
                    structure.moveTo(-30, -20);
                    structure.lineTo(0, -35);
                    structure.lineTo(30, -20);
                    structure.closePath();
                    structure.endFill();
                } else if (pos.type === 'cave') {
                    // Cave entrance
                    structure.beginFill(0x696969);
                    structure.drawEllipse(0, 0, 35, 25);
                    structure.endFill();
                    
                    structure.beginFill(0x000000);
                    structure.drawEllipse(0, 0, 25, 18);
                    structure.endFill();
                }
                
                structure.x = pos.x;
                structure.y = 1500 - pos.y;
                structure.interactive = true;
                structure.buttonMode = true;
                
                // Store structure data
                worldObjects.structures.push({
                    sprite: structure,
                    x: pos.x,
                    y: pos.y,
                    type: pos.type
                });
                
                backgroundContainer.addChild(structure);
            });
            
            // Add fantasy world features
            createWorldFeatures();
            
            // Create procedural monsters
            createProceduralMonsters();
            
            // Add environmental details
            createEnvironmentalDetails();

            console.log('World objects created:', worldObjects);
        }

        // Define monster archetypes with procedural traits
        const monsterArchetypes = {
            humanoid: {
                types: ['goblin', 'orc', 'hobgoblin', 'dwarf', 'human_bandit', 'skeleton', 'zombie'],
                baseStats: { health: 50, attack: 20, speed: 1.0 }
            },
            beast: {
                types: ['wolf', 'bear', 'wild_boar', 'dire_wolf', 'shadow_cat', 'giant_rat'],
                baseStats: { health: 60, attack: 25, speed: 1.2 }
            },
            magical: {
                types: ['elemental', 'wraith', 'imp', 'wisp', 'golem', 'sprite'],
                baseStats: { health: 40, attack: 30, speed: 0.8 }
            }
        };

        function createProceduralMonsters() {
            if (!pixiContainer) return;
            
            // Define spawn areas with archetype preferences
            const spawnAreas = [
                // Forest areas favor beasts
                {region: 'forest', x: 300, y: 400, radius: 150, archetype: 'beast', count: 3},
                {region: 'deep_forest', x: 1700, y: 1200, radius: 200, archetype: 'beast', count: 4},
                
                // Cave/rocky areas favor humanoids
                {region: 'caves', x: 800, y: 1300, radius: 180, archetype: 'humanoid', count: 5},
                {region: 'ruins', x: 1200, y: 300, radius: 160, archetype: 'humanoid', count: 4},
                
                // Mystical areas favor magical creatures
                {region: 'mystical_grove', x: 600, y: 800, radius: 120, archetype: 'magical', count: 2},
                {region: 'ancient_stones', x: 1500, y: 600, radius: 140, archetype: 'magical', count: 3}
            ];
            
            spawnAreas.forEach(area => {
                for (let i = 0; i < area.count; i++) {
                    // Random position within area
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * area.radius;
                    const x = area.x + Math.cos(angle) * distance;
                    const y = area.y + Math.sin(angle) * distance;
                    
                    // Ensure within world bounds
                    const clampedX = Math.max(100, Math.min(1900, x));
                    const clampedY = Math.max(100, Math.min(1400, y));
                    
                    // Select random monster type from archetype
                    const archetype = monsterArchetypes[area.archetype];
                    const type = archetype.types[Math.floor(Math.random() * archetype.types.length)];
                    
                    // Generate procedural traits
                    const traits = generateMonsterTraits(type, area.archetype);
                    
                    // Create monster sprite
                    const monster = createMonsterSprite(type, area.archetype, traits);
                    
                    // Position monster
                    monster.x = clampedX;
                    monster.y = 1500 - clampedY;
                    monster.interactive = true;
                    monster.buttonMode = true;
                    
                    // Store monster data
                    worldObjects.monsters.push({
                        sprite: monster,
                        x: clampedX,
                        y: clampedY,
                        type: type,
                        archetype: area.archetype,
                        traits: traits,
                        health: traits.health,
                        maxHealth: traits.health,
                        attack: traits.attack,
                        speed: traits.speed,
                        level: traits.level,
                        behavior: traits.behavior,
                        animations: {
                            timer: Math.random() * 100,
                            direction: Math.random() * Math.PI * 2,
                            speed: 0.2 + Math.random() * 0.3,
                            pauseTimer: 0,
                            isPaused: false
                        }
                    });
                    
                    entityContainer.addChild(monster);
                }
            });
            
            console.log('Created', worldObjects.monsters.length, 'procedural monsters');
        }

        function generateMonsterTraits(type, archetype) {
            const baseStats = monsterArchetypes[archetype].baseStats;
            const level = 1 + Math.floor(Math.random() * 5);
            
            // Generate colors based on type
            const colors = generateMonsterColors(type, archetype);
            
            // Generate equipment for humanoids
            const equipment = archetype === 'humanoid' ? generateEquipment(type, level) : null;
            
            // Calculate stats with level scaling and randomization
            const healthVariation = 0.7 + Math.random() * 0.6;
            const attackVariation = 0.8 + Math.random() * 0.4;
            const speedVariation = 0.9 + Math.random() * 0.2;
            
            return {
                level: level,
                size: 0.8 + Math.random() * 0.6,
                health: Math.floor(baseStats.health * healthVariation * (1 + level * 0.2)) + (equipment ? equipment.totalDefense * 5 : 0),
                attack: Math.floor(baseStats.attack * attackVariation * (1 + level * 0.15)) + (equipment ? equipment.totalDamage : 0),
                speed: baseStats.speed * speedVariation,
                colors: colors,
                behavior: ['aggressive', 'defensive', 'neutral', 'territorial'][Math.floor(Math.random() * 4)],
                equipment: equipment
            };
        }

        function generateEquipment(monsterType, level) {
            const equipment = {
                weapon: null,
                armor: null,
                helmet: null,
                accessories: [],
                totalDamage: 0,
                totalDefense: 0
            };
            
            // Equipment probability based on monster type and level
            const equipmentChance = {
                goblin: { weapon: 0.6, armor: 0.3, helmet: 0.2, accessories: 0.4 },
                orc: { weapon: 0.8, armor: 0.6, helmet: 0.4, accessories: 0.3 },
                hobgoblin: { weapon: 0.9, armor: 0.8, helmet: 0.6, accessories: 0.5 },
                dwarf: { weapon: 0.7, armor: 0.9, helmet: 0.8, accessories: 0.7 },
                human_bandit: { weapon: 0.8, armor: 0.5, helmet: 0.3, accessories: 0.6 },
                skeleton: { weapon: 0.5, armor: 0.2, helmet: 0.1, accessories: 0.2 },
                zombie: { weapon: 0.3, armor: 0.1, helmet: 0.1, accessories: 0.1 }
            };
            
            const chances = equipmentChance[monsterType] || equipmentChance.goblin;
            
            // Generate weapon
            if (Math.random() < chances.weapon) {
                const weapons = Object.keys(equipmentData.weapons);
                const weaponKey = weapons[Math.floor(Math.random() * weapons.length)];
                equipment.weapon = { ...equipmentData.weapons[weaponKey], key: weaponKey };
                equipment.totalDamage += equipment.weapon.damage;
            }
            
            // Generate armor
            if (Math.random() < chances.armor) {
                const armors = Object.keys(equipmentData.armor);
                const armorKey = armors[Math.floor(Math.random() * armors.length)];
                equipment.armor = { ...equipmentData.armor[armorKey], key: armorKey };
                equipment.totalDefense += equipment.armor.defense;
            }
            
            // Generate helmet
            if (Math.random() < chances.helmet) {
                const helmets = Object.keys(equipmentData.helmets);
                const helmetKey = helmets[Math.floor(Math.random() * helmets.length)];
                equipment.helmet = { ...equipmentData.helmets[helmetKey], key: helmetKey };
                equipment.totalDefense += equipment.helmet.defense;
            }
            
            // Generate accessories
            if (Math.random() < chances.accessories) {
                const accessories = Object.keys(equipmentData.accessories);
                const accessoryKey = accessories[Math.floor(Math.random() * accessories.length)];
                equipment.accessories.push({ ...equipmentData.accessories[accessoryKey], key: accessoryKey });
            }
            
            return equipment;
        }

        function generateMonsterColors(type, archetype) {
            const colorPalettes = {
                // Humanoid colors
                goblin: { skin: 0x228B22, eyes: 0xFF0000, clothing: 0x8B4513 },
                orc: { skin: 0x556B2F, eyes: 0xFF4500, clothing: 0x2F4F2F },
                hobgoblin: { skin: 0x8B0000, eyes: 0xFFFF00, clothing: 0x654321 },
                dwarf: { skin: 0xDEB887, eyes: 0x4169E1, hair: 0x8B4513, clothing: 0x4682B4 },
                human_bandit: { skin: 0xFFDBAE, eyes: 0x654321, clothing: 0x2F2F2F },
                skeleton: { bone: 0xFFFFFF, eyes: 0xFF0000 },
                zombie: { skin: 0x9ACD32, eyes: 0x8B0000, clothing: 0x556B2F },
                
                // Beast colors
                wolf: { fur: 0x696969, eyes: 0xFFFF00 },
                bear: { fur: 0x8B4513, eyes: 0x654321 },
                wild_boar: { fur: 0x2F4F2F, eyes: 0xFF4500, tusks: 0xFFFFFF },
                dire_wolf: { fur: 0x2F2F2F, eyes: 0xFF0000 },
                shadow_cat: { fur: 0x191970, eyes: 0x9932CC },
                giant_rat: { fur: 0x696969, eyes: 0xFF0000 },
                
                // Magical colors
                elemental: { body: 0x4169E1, glow: 0x00FFFF },
                wraith: { body: 0x9370DB, glow: 0xDDA0DD },
                imp: { skin: 0x8B0000, eyes: 0xFFFF00, wings: 0x2F2F2F },
                wisp: { body: 0x00FF7F, glow: 0x90EE90 },
                golem: { body: 0x696969, eyes: 0xFF0000 },
                sprite: { body: 0xFFB6C1, wings: 0x98FB98, glow: 0xFFFFFF }
            };
            
            const baseColors = colorPalettes[type];
            if (!baseColors) return colorPalettes.goblin;
            
            // Add slight random variations
            const result = {};
            Object.keys(baseColors).forEach(colorType => {
                const base = baseColors[colorType];
                const variation = Math.floor(Math.random() * 40) - 20;
                result[colorType] = Math.max(0, Math.min(0xFFFFFF, base + variation));
            });
            
            return result;
        }

        function createMonsterSprite(type, archetype, traits) {
            const monsterContainer = new PIXI.Container();
            const scale = traits.size;
            
            if (archetype === 'humanoid') {
                return createHumanoidSprite(type, traits, scale, monsterContainer);
            } else if (archetype === 'beast') {
                return createBeastSprite(type, traits, scale, monsterContainer);
            } else if (archetype === 'magical') {
                return createMagicalSprite(type, traits, scale, monsterContainer);
            }
            
            return monsterContainer;
        }

        function createHumanoidSprite(type, traits, scale, container) {
            const colors = traits.colors;
            
            // Body (torso)
            const body = new PIXI.Graphics();
            body.beginFill(colors.skin || colors.bone || 0x8B4513);
            if (type === 'skeleton') {
                // Skeleton ribcage
                body.drawEllipse(0, 0, 10 * scale, 15 * scale);
                body.beginFill(colors.bone || 0xFFFFFF, 0.8);
                for (let i = 0; i < 3; i++) {
                    body.drawRect(-8 * scale, (-5 + i * 5) * scale, 16 * scale, 1 * scale);
                }
            } else {
                body.drawEllipse(0, 0, 12 * scale, 18 * scale);
            }
            body.endFill();
            
            // Head
            const head = new PIXI.Graphics();
            head.beginFill(colors.skin || colors.bone || 0x8B4513);
            head.drawCircle(0, -20 * scale, 8 * scale);
            head.endFill();
            
            // Eyes
            const eyes = new PIXI.Graphics();
            eyes.beginFill(colors.eyes || 0xFF0000);
            eyes.drawCircle(-3 * scale, -22 * scale, 2 * scale);
            eyes.drawCircle(3 * scale, -22 * scale, 2 * scale);
            eyes.endFill();
            
            // Arms
            const leftArm = new PIXI.Graphics();
            const rightArm = new PIXI.Graphics();
            leftArm.beginFill(colors.skin || colors.bone || 0x8B4513, 0.9);
            rightArm.beginFill(colors.skin || colors.bone || 0x8B4513, 0.9);
            leftArm.drawEllipse(-12 * scale, 0, 4 * scale, 12 * scale);
            rightArm.drawEllipse(12 * scale, 0, 4 * scale, 12 * scale);
            leftArm.endFill();
            rightArm.endFill();
            
            // Legs
            const leftLeg = new PIXI.Graphics();
            const rightLeg = new PIXI.Graphics();
            leftLeg.beginFill(colors.skin || colors.bone || 0x8B4513, 0.9);
            rightLeg.beginFill(colors.skin || colors.bone || 0x8B4513, 0.9);
            leftLeg.drawEllipse(-4 * scale, 18 * scale, 5 * scale, 12 * scale);
            rightLeg.drawEllipse(4 * scale, 18 * scale, 5 * scale, 12 * scale);
            leftLeg.endFill();
            rightLeg.endFill();
            
            // Hair/helmet for certain types
            if (type === 'dwarf' && colors.hair) {
                const hair = new PIXI.Graphics();
                hair.beginFill(colors.hair);
                hair.drawCircle(0, -22 * scale, 9 * scale);
                hair.endFill();
                container.addChild(hair);
            }
            
            // Special features for specific types
            if (type === 'wild_boar' && colors.tusks) {
                const tusks = new PIXI.Graphics();
                tusks.beginFill(colors.tusks);
                tusks.drawEllipse(-22 * scale, 2 * scale, 2 * scale, 4 * scale);
                tusks.drawEllipse(-22 * scale, -2 * scale, 2 * scale, 4 * scale);
                tusks.endFill();
                container.addChild(tusks);
            }
            
            // Add equipment rendering
            if (traits.equipment) {
                const equipment = traits.equipment;
                
                // Armor overlay on body
                if (equipment.armor) {
                    const armor = new PIXI.Graphics();
                    const armorColor = typeof equipment.armor.color === 'string' ? 
                        parseInt(equipment.armor.color.replace('#', '0x')) : equipment.armor.color;
                    armor.beginFill(armorColor || 0x8B4513, 0.8);
                    armor.drawEllipse(0, 0, 13 * scale, 19 * scale);
                    armor.endFill();
                    container.addChild(armor);
                }
                
                // Helmet over head
                if (equipment.helmet) {
                    const helmet = new PIXI.Graphics();
                    const helmetColor = typeof equipment.helmet.color === 'string' ? 
                        parseInt(equipment.helmet.color.replace('#', '0x')) : equipment.helmet.color;
                    helmet.beginFill(helmetColor || 0x696969, 0.9);
                    helmet.drawEllipse(0, -20 * scale, 9 * scale, 7 * scale);
                    helmet.endFill();
                    container.addChild(helmet);
                }
                
                // Weapon in left hand
                if (equipment.weapon) {
                    const weapon = new PIXI.Graphics();
                    const weaponColor = typeof equipment.weapon.color === 'string' ? 
                        parseInt(equipment.weapon.color.replace('#', '0x')) : equipment.weapon.color;
                    weapon.beginFill(weaponColor || 0xC0C0C0);
                    
                    // Different weapon shapes
                    if (equipment.weapon.key === 'sword' || equipment.weapon.key === 'dagger') {
                        weapon.drawRect(-18 * scale, -2 * scale, 8 * scale, 2 * scale);
                    } else if (equipment.weapon.key === 'axe') {
                        weapon.drawPolygon([-18 * scale, 0, -20 * scale, -3 * scale, -14 * scale, -3 * scale, -16 * scale, 3 * scale]);
                    } else if (equipment.weapon.key === 'mace') {
                        weapon.drawCircle(-18 * scale, 0, 3 * scale);
                        weapon.drawRect(-16 * scale, -1 * scale, 4 * scale, 2 * scale);
                    } else if (equipment.weapon.key === 'staff') {
                        weapon.drawRect(-20 * scale, -1 * scale, 12 * scale, 1 * scale);
                        weapon.drawCircle(-21 * scale, 0, 2 * scale);
                    } else if (equipment.weapon.key === 'bow') {
                        weapon.drawEllipse(-18 * scale, 0, 2 * scale, 8 * scale);
                    } else {
                        weapon.drawRect(-18 * scale, -1 * scale, 6 * scale, 2 * scale);
                    }
                    weapon.endFill();
                    container.addChild(weapon);
                }
                
                // Belt/accessories around waist
                if (equipment.accessories && equipment.accessories.length > 0) {
                    const belt = equipment.accessories.find(acc => acc.key === 'belt');
                    if (belt) {
                        const beltGraphic = new PIXI.Graphics();
                        const beltColor = typeof belt.color === 'string' ? 
                            parseInt(belt.color.replace('#', '0x')) : belt.color;
                        beltGraphic.beginFill(beltColor || 0x654321);
                        beltGraphic.drawRect(-12 * scale, 8 * scale, 24 * scale, 2 * scale);
                        beltGraphic.endFill();
                        container.addChild(beltGraphic);
                    }
                }
            }
            
            // Assembly
            container.addChild(leftArm);
            container.addChild(rightArm);
            container.addChild(leftLeg);
            container.addChild(rightLeg);
            container.addChild(body);
            container.addChild(head);
            container.addChild(eyes);
            
            return container;
        }

        function createBeastSprite(type, traits, scale, container) {
            const colors = traits.colors;
            
            // Main body
            const body = new PIXI.Graphics();
            body.beginFill(colors.fur || 0x8B4513);
            if (type === 'bear') {
                body.drawEllipse(0, 0, 20 * scale, 15 * scale);
            } else if (type === 'wolf' || type === 'dire_wolf') {
                body.drawEllipse(0, 0, 18 * scale, 12 * scale);
            } else {
                body.drawEllipse(0, 0, 15 * scale, 10 * scale);
            }
            body.endFill();
            
            // Head
            const head = new PIXI.Graphics();
            head.beginFill(colors.fur || 0x8B4513);
            if (type === 'bear') {
                head.drawCircle(-15 * scale, 0, 10 * scale);
            } else {
                head.drawEllipse(-12 * scale, 0, 8 * scale, 6 * scale);
            }
            head.endFill();
            
            // Eyes
            const eyes = new PIXI.Graphics();
            eyes.beginFill(colors.eyes || 0xFFFF00);
            eyes.drawCircle(-18 * scale, -2 * scale, 2 * scale);
            eyes.drawCircle(-10 * scale, -2 * scale, 2 * scale);
            eyes.endFill();
            
            // Legs (4 legs for beasts)
            const legs = [];
            for (let i = 0; i < 4; i++) {
                const leg = new PIXI.Graphics();
                leg.beginFill(colors.fur || 0x8B4513, 0.9);
                leg.drawEllipse(0, 0, 3 * scale, 8 * scale);
                leg.endFill();
                leg.x = (-8 + i * 5) * scale;
                leg.y = 10 * scale;
                legs.push(leg);
            }
            
            // Tail
            const tail = new PIXI.Graphics();
            tail.beginFill(colors.fur || 0x8B4513);
            tail.drawEllipse(15 * scale, 2 * scale, 6 * scale, 4 * scale);
            tail.endFill();
            
            // Special features
            if (type === 'wild_boar' && colors.tusks) {
                const tusks = new PIXI.Graphics();
                tusks.beginFill(colors.tusks);
                tusks.drawEllipse(-22 * scale, 2 * scale, 2 * scale, 4 * scale);
                tusks.drawEllipse(-22 * scale, -2 * scale, 2 * scale, 4 * scale);
                tusks.endFill();
                container.addChild(tusks);
            }
            
            // Assembly
            container.addChild(tail);
            legs.forEach(leg => container.addChild(leg));
            container.addChild(body);
            container.addChild(head);
            container.addChild(eyes);
            
            return container;
        }

        function createMagicalSprite(type, traits, scale, container) {
            const colors = traits.colors;
            
            if (type === 'elemental') {
                // Swirling elemental form
                const body = new PIXI.Graphics();
                body.beginFill(colors.body || 0x4169E1, 0.8);
                body.drawCircle(0, 0, 12 * scale);
                body.endFill();
                
                // Elemental swirls
                const swirl = new PIXI.Graphics();
                swirl.beginFill(colors.glow || 0x00FFFF, 0.6);
                swirl.drawCircle(-6 * scale, 0, 4 * scale);
                swirl.drawCircle(6 * scale, 0, 4 * scale);
                swirl.drawCircle(0, -6 * scale, 4 * scale);
                swirl.endFill();
                
                container.addChild(body);
                container.addChild(swirl);
                
            } else if (type === 'wraith') {
                // Ethereal wraith form
                const body = new PIXI.Graphics();
                body.beginFill(colors.body || 0x9370DB, 0.7);
                body.drawEllipse(0, 0, 15 * scale, 20 * scale);
                body.endFill();
                
                // Glowing eyes
                const eyes = new PIXI.Graphics();
                eyes.beginFill(colors.glow || 0x00FFFF);
                eyes.drawCircle(-5 * scale, -8 * scale, 3 * scale);
                eyes.drawCircle(5 * scale, -8 * scale, 3 * scale);
                eyes.endFill();
                
                container.addChild(body);
                container.addChild(eyes);
                
            } else if (type === 'golem') {
                // Stone construct
                const body = new PIXI.Graphics();
                body.beginFill(colors.body || 0x696969);
                body.drawRect(-10 * scale, -15 * scale, 20 * scale, 30 * scale);
                body.endFill();
                
                // Glowing core
                const core = new PIXI.Graphics();
                core.beginFill(colors.eyes || 0xFF0000);
                core.drawCircle(0, 0, 4 * scale);
                core.endFill();
                
                container.addChild(body);
                container.addChild(core);
                
            } else {
                // Default magical creature
                const body = new PIXI.Graphics();
                body.beginFill(colors.body || 0x9400D3, 0.8);
                body.drawCircle(0, 0, 10 * scale);
                body.endFill();
                
                container.addChild(body);
            }
            
            return container;
        }
        
        function createEnvironmentalDetails() {
            if (!backgroundContainer) return;
            
            // Create rocks scattered around
            const rockPositions = [
                {x: 200, y: 300}, {x: 400, y: 500}, {x: 1800, y: 600},
                {x: 600, y: 1200}, {x: 1400, y: 200}, {x: 300, y: 800},
                {x: 1600, y: 1000}, {x: 800, y: 200}, {x: 1200, y: 1400}
            ];
            
            rockPositions.forEach((pos, index) => {
                const rock = new PIXI.Graphics();
                const scale = 0.5 + Math.random() * 0.8;
                const rockColor = [0x696969, 0x2F4F4F, 0x778899][index % 3];
                
                rock.beginFill(rockColor);
                rock.drawEllipse(0, 0, 15 * scale, 12 * scale);
                rock.endFill();
                
                // Add highlight
                rock.beginFill(0xD3D3D3);
                rock.drawEllipse(-3 * scale, -2 * scale, 6 * scale, 4 * scale);
                rock.endFill();
                
                rock.x = pos.x;
                rock.y = 1500 - pos.y;
                backgroundContainer.addChild(rock);
            });
            
            // Create flower patches
            const flowerPositions = [
                {x: 350, y: 650}, {x: 750, y: 850}, {x: 1150, y: 450},
                {x: 1550, y: 950}, {x: 450, y: 1150}, {x: 1350, y: 350}
            ];
            
            flowerPositions.forEach((pos, index) => {
                const flowerPatch = new PIXI.Graphics();
                const colors = [
                    [0xFF69B4, 0xFFB6C1], // Pink flowers
                    [0x9370DB, 0xDDA0DD], // Purple flowers  
                    [0xFFD700, 0xFFFACD], // Yellow flowers
                    [0xFF6347, 0xFFA07A], // Orange flowers
                    [0x00CED1, 0xAFEEEE], // Cyan flowers
                    [0xFFFFFF, 0xF0F8FF]  // White flowers
                ];
                
                const colorPair = colors[index % colors.length];
                
                // Create several small flowers in a patch
                for (let i = 0; i < 5; i++) {
                    const offsetX = (Math.random() - 0.5) * 20;
                    const offsetY = (Math.random() - 0.5) * 20;
                    
                    flowerPatch.beginFill(colorPair[0]);
                    flowerPatch.drawCircle(offsetX, offsetY, 2);
                    flowerPatch.endFill();
                    
                    flowerPatch.beginFill(colorPair[1]);
                    flowerPatch.drawCircle(offsetX, offsetY, 1);
                    flowerPatch.endFill();
                }
                
                flowerPatch.x = pos.x;
                flowerPatch.y = 1500 - pos.y;
                pixiContainer.addChild(flowerPatch);
            });
            
            // Create dirt paths
            const pathPoints = [
                {x: 0, y: 750}, {x: 500, y: 750}, {x: 800, y: 600}, 
                {x: 1200, y: 600}, {x: 1500, y: 750}, {x: 2000, y: 750}
            ];
            
            for (let i = 0; i < pathPoints.length - 1; i++) {
                const path = new PIXI.Graphics();
                const start = pathPoints[i];
                const end = pathPoints[i + 1];
                
                path.beginFill(0x8B7355);
                path.moveTo(start.x, 1500 - start.y - 10);
                path.lineTo(end.x, 1500 - end.y - 10);
                path.lineTo(end.x, 1500 - end.y + 10);
                path.lineTo(start.x, 1500 - start.y + 10);
                path.closePath();
                path.endFill();
                
                pixiContainer.addChild(path);
            }
            
            // Add some mushrooms
            const mushroomPositions = [
                {x: 150, y: 400}, {x: 850, y: 1100}, {x: 1750, y: 800}
            ];
            
            mushroomPositions.forEach(pos => {
                const mushroom = new PIXI.Graphics();
                
                // Mushroom stem
                mushroom.beginFill(0xF5DEB3);
                mushroom.drawRect(-2, -8, 4, 8);
                mushroom.endFill();
                
                // Mushroom cap
                mushroom.beginFill(0xDC143C);
                mushroom.drawEllipse(0, -12, 8, 6);
                mushroom.endFill();
                
                // White spots
                mushroom.beginFill(0xFFFFFF);
                mushroom.drawCircle(-3, -10, 1);
                mushroom.drawCircle(2, -12, 1);
                mushroom.drawCircle(0, -14, 1);
                mushroom.endFill();
                
                mushroom.x = pos.x;
                mushroom.y = 1500 - pos.y;
                pixiContainer.addChild(mushroom);
            });
        }

        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keysPressed[e.code] = true;
                if (!isMoving) {
                    startMovement();
                }
            });

            document.addEventListener('keyup', (e) => {
                delete keysPressed[e.code];
                if (Object.keys(keysPressed).length === 0) {
                    stopMovement();
                }
            });

            // Start animation loop
            pixiApp.ticker.add(updateGame);
            
            // Mouse/Touch controls for world interaction
            const worldView = document.getElementById('worldView');
            worldView.addEventListener('click', (e) => {
                const rect = worldView.getBoundingClientRect();
                const clickX = (e.clientX - rect.left) / currentZoom + cameraPosition.x;
                const clickY = (e.clientY - rect.top) / currentZoom + cameraPosition.y;
                
                // Check for object interactions
                handleWorldInteraction(clickX, clickY);
            });
        }

        function startMovement() {
            isMoving = true;
        }

        function stopMovement() {
            isMoving = false;
        }

        function createWanderingDragons() {
            if (!pixiApp || !entityContainer) return;
            
            worldObjects.wanderingDragons = [];
            
            // Create several wandering dragons with different types and sizes
            const wanderingDragonData = [
                // Ancient Dragon - truly impressive and far from village
                {
                    x: 200, y: 200, type: 'ancient', level: 15, 
                    personality: 'wise', size: 2.5,
                    colors: {body: 0x800080, accent: 0x9932CC, eyes: 0xFFD700},
                    traits: {hasWings: true, hasHorns: true, tailType: 'spiked'}
                },
                // Elder Fire Dragon
                {
                    x: 1800, y: 300, type: 'fire', level: 8,
                    personality: 'fierce', size: 1.8,
                    colors: {body: 0x8B0000, accent: 0xFF4500, eyes: 0xFFFF00},
                    traits: {hasWings: true, hasHorns: true, tailType: 'barbed'}
                },
                // Ice Dragon
                {
                    x: 300, y: 1200, type: 'ice', level: 6,
                    personality: 'calm', size: 1.5,
                    colors: {body: 0x4169E1, accent: 0x87CEEB, eyes: 0xFFFFFF},
                    traits: {hasWings: true, hasHorns: false, tailType: 'smooth'}
                },
                // Earth Dragon  
                {
                    x: 1600, y: 1100, type: 'earth', level: 7,
                    personality: 'stoic', size: 1.7,
                    colors: {body: 0x8B4513, accent: 0xDEB887, eyes: 0x228B22},
                    traits: {hasWings: false, hasHorns: true, tailType: 'thick'}
                }
            ];
            
            wanderingDragonData.forEach(data => {
                const dragon = createWanderingDragonSprite(data);
                
                const wanderingDragon = {
                    sprite: dragon,
                    x: data.x,
                    y: data.y,
                    type: data.type,
                    level: data.level,
                    personality: data.personality,
                    size: data.size,
                    colors: data.colors,
                    traits: data.traits,
                    animations: {
                        timer: 0,
                        direction: Math.random() * Math.PI * 2,
                        speed: 0.3,
                        homeX: data.x,
                        homeY: data.y,
                        wanderRadius: data.type === 'ancient' ? 200 : 150,
                        breatheTimer: Math.random() * 360,
                        blinkTimer: Math.random() * 180 // For eye blinking
                    }
                };
                
                // Ensure initial position is set correctly
                dragon.x = data.x;
                dragon.y = 1500 - data.y;
                
                worldObjects.wanderingDragons.push(wanderingDragon);
                entityContainer.addChild(dragon);
            });
            
            console.log('Created', worldObjects.wanderingDragons.length, 'wandering dragons');
        }
        
        function createWanderingDragonSprite(data) {
            const dragonContainer = new PIXI.Container();
            const scale = data.size;
            
            // Dragon body (main torso) - using companion dragon style
            const body = new PIXI.Graphics();
            body.beginFill(data.colors.body);
            body.drawEllipse(0, 0, 25 * scale, 15 * scale);
            body.endFill();
            
            // Dragon head - using companion dragon style
            const head = new PIXI.Graphics();
            head.beginFill(data.colors.body);
            head.drawEllipse(-20 * scale, -5 * scale, 15 * scale, 12 * scale);
            head.endFill();
            
            // Dragon tail - adaptive based on traits like companion
            const tail = new PIXI.Graphics();
            tail.beginFill(data.colors.body);
            if (data.traits.tailType === 'spiked' || data.traits.tailType === 'barbed') {
                // Spiked tail
                tail.moveTo(20 * scale, 0);
                tail.lineTo(35 * scale, -5 * scale);
                tail.lineTo(40 * scale, 0);
                tail.lineTo(35 * scale, 5 * scale);
                tail.closePath();
            } else if (data.traits.tailType === 'smooth' || data.traits.tailType === 'wispy') {
                // Smooth/wispy tail
                tail.drawEllipse(30 * scale, 0, 12 * scale, 6 * scale);
            } else {
                // Default thick tail
                tail.drawEllipse(28 * scale, 0, 15 * scale, 8 * scale);
            }
            tail.endFill();
            
            // Dragon wings (if has wings) - using companion dragon style
            let leftWing = null, rightWing = null;
            if (data.traits.hasWings) {
                leftWing = new PIXI.Graphics();
                leftWing.beginFill(data.colors.accent);
                leftWing.moveTo(-10 * scale, -10 * scale);
                leftWing.lineTo(-25 * scale, -20 * scale);
                leftWing.lineTo(-15 * scale, -35 * scale);
                leftWing.lineTo(0, -25 * scale);
                leftWing.closePath();
                leftWing.endFill();
                
                rightWing = new PIXI.Graphics();
                rightWing.beginFill(data.colors.accent);
                rightWing.moveTo(10 * scale, -10 * scale);
                rightWing.lineTo(25 * scale, -20 * scale);
                rightWing.lineTo(15 * scale, -35 * scale);
                rightWing.lineTo(0, -25 * scale);
                rightWing.closePath();
                rightWing.endFill();
            }
            
            // Dragon horns (if has horns) - using companion dragon style  
            let leftHorn = null, rightHorn = null;
            if (data.traits.hasHorns) {
                leftHorn = new PIXI.Graphics();
                leftHorn.beginFill(data.colors.accent);
                leftHorn.moveTo(-25 * scale, -8 * scale);
                leftHorn.lineTo(-30 * scale, -18 * scale);
                leftHorn.lineTo(-22 * scale, -15 * scale);
                leftHorn.closePath();
                leftHorn.endFill();
                
                rightHorn = new PIXI.Graphics();
                rightHorn.beginFill(data.colors.accent);
                rightHorn.moveTo(-15 * scale, -8 * scale);
                rightHorn.lineTo(-20 * scale, -18 * scale);
                rightHorn.lineTo(-12 * scale, -15 * scale);
                rightHorn.closePath();
                rightHorn.endFill();
            }
            
            // Dragon legs - using companion dragon style (4 separate legs)
            const leg1 = new PIXI.Graphics();
            leg1.beginFill(data.colors.body);
            leg1.drawEllipse(-15 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg1.endFill();
            
            const leg2 = new PIXI.Graphics();
            leg2.beginFill(data.colors.body);
            leg2.drawEllipse(-5 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg2.endFill();
            
            const leg3 = new PIXI.Graphics();
            leg3.beginFill(data.colors.body);
            leg3.drawEllipse(5 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg3.endFill();
            
            const leg4 = new PIXI.Graphics();
            leg4.beginFill(data.colors.body);
            leg4.drawEllipse(15 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg4.endFill();
            
            // Dragon eyes - using companion dragon style
            const eyes = new PIXI.Graphics();
            eyes.beginFill(data.colors.eyes);
            eyes.drawCircle(-25 * scale, -8 * scale, 2 * scale);
            eyes.drawCircle(-20 * scale, -8 * scale, 2 * scale);
            eyes.endFill();
            
            // Assemble dragon sprite in proper order (same as companion)
            dragonContainer.addChild(tail);
            dragonContainer.addChild(leg1);
            dragonContainer.addChild(leg2);
            dragonContainer.addChild(leg3);
            dragonContainer.addChild(leg4);
            dragonContainer.addChild(body);
            dragonContainer.addChild(head);
            
            if (leftWing && rightWing) {
                dragonContainer.addChild(leftWing);
                dragonContainer.addChild(rightWing);
            }
            
            if (leftHorn && rightHorn) {
                dragonContainer.addChild(leftHorn);
                dragonContainer.addChild(rightHorn);
            }
            
            dragonContainer.addChild(eyes);
            
            // Store references for animation (same structure as companion)
            dragonContainer.bodyParts = {
                body, head, tail, eyes, legs: [leg1, leg2, leg3, leg4],
                wings: leftWing && rightWing ? [leftWing, rightWing] : null,
                horns: leftHorn && rightHorn ? [leftHorn, rightHorn] : null
            };
            
            // Set position
            dragonContainer.x = data.x;
            dragonContainer.y = 1500 - data.y;
            
            return dragonContainer;
        }

        function updateGame() {
            gameFrame++;
            
            // Handle movement
            if (isMoving) {
                let dx = 0;
                let dy = 0;

                // Collect input directions
                if (keysPressed['KeyW'] || keysPressed['ArrowUp']) dy += 1;
                if (keysPressed['KeyS'] || keysPressed['ArrowDown']) dy -= 1;
                if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) dx -= 1;
                if (keysPressed['KeyD'] || keysPressed['ArrowRight']) dx += 1;

                // Update player direction based on movement
                if (dx !== 0 || dy !== 0) {
                    let newDirection = playerDirection;
                    
                    // Prioritize vertical movement for direction
                    if (dy > 0) newDirection = 'up';
                    else if (dy < 0) newDirection = 'down';
                    else if (dx < 0) newDirection = 'left';
                    else if (dx > 0) newDirection = 'right';
                    
                    if (newDirection !== playerDirection) {
                        playerDirection = newDirection;
                        updatePlayerDirection();
                    }
                }

                // Normalize diagonal movement to maintain consistent speed
                if (dx !== 0 && dy !== 0) {
                    // Diagonal movement - normalize by sqrt(2)
                    dx *= 0.707;
                    dy *= 0.707;
                }

                // Apply movement
                let newX = playerPosition.x + dx * moveSpeed;
                let newY = playerPosition.y + dy * moveSpeed;

                // Clamp to world bounds
                newX = Math.max(50, Math.min(1950, newX));
                newY = Math.max(50, Math.min(1450, newY));

                playerPosition.x = newX;
                playerPosition.y = newY;

                // Update player sprite position
                if (playerSprite) {
                    playerSprite.x = playerPosition.x;
                    playerSprite.y = 1500 - playerPosition.y;
                }

                // Update camera
                updateCamera();
                updateMiniMap();
                
                // Refresh minimap entities periodically
                if (gameFrame % 60 === 0) { // Every 60 frames (~1 second)
                    drawMiniMapEntities(document.getElementById('miniMapCanvas').getContext('2d'), 180, 120);
                }
            }
            
            // Update dragon AI and animations
            updateDragon();
            
            // Update sheep animations
            updateSheepAnimations();
            
            // Update wandering dragons
            updateWanderingDragons();
            
            // Update wandering monsters
            updateWanderingMonsters();
        }

        function updateCamera() {
            // Calculate target camera position to center on player
            const viewWidth = window.innerWidth;
            const viewHeight = window.innerHeight;
            
            // Center camera on player position
            targetCameraPosition.x = playerPosition.x - (viewWidth / 2) / currentZoom;
            targetCameraPosition.y = (1500 - playerPosition.y) - (viewHeight / 2) / currentZoom;

            // Clamp camera to world bounds
            const maxCameraX = 2000 - (viewWidth / currentZoom);
            const maxCameraY = 1500 - (viewHeight / currentZoom);
            
            targetCameraPosition.x = Math.max(0, Math.min(maxCameraX, targetCameraPosition.x));
            targetCameraPosition.y = Math.max(0, Math.min(maxCameraY, targetCameraPosition.y));

            // Smooth camera movement
            if (smoothCameraFollow) {
                cameraPosition.x += (targetCameraPosition.x - cameraPosition.x) * 0.1;
                cameraPosition.y += (targetCameraPosition.y - cameraPosition.y) * 0.1;
            } else {
                cameraPosition.x = targetCameraPosition.x;
                cameraPosition.y = targetCameraPosition.y;
            }

            // Apply camera transform
            const worldContainer = document.getElementById('worldContainer');
            if (worldContainer) {
                worldContainer.style.transform = `translate(${-cameraPosition.x * currentZoom}px, ${-cameraPosition.y * currentZoom}px) scale(${currentZoom})`;
            }
        }

        function updateMiniMap() {
            const miniPlayer = document.getElementById('miniPlayer');
            if (miniPlayer) {
                // Convert world coordinates to minimap coordinates
                const miniX = (playerPosition.x / 2000) * 180 - 2;
                const miniY = (playerPosition.y / 1500) * 120 - 2;
                
                miniPlayer.style.left = miniX + 'px';
                miniPlayer.style.top = (120 - miniY) + 'px'; // Flip Y for minimap
            }
        }

        function initializeMiniMap() {
            const canvas = document.getElementById('miniMapCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw terrain layers
            drawMiniMapTerrain(ctx, width, height);
            drawMiniMapFeatures(ctx, width, height);
            drawMiniMapEntities(ctx, width, height);
            
            console.log('Enhanced minimap initialized');
        }

        function drawMiniMapTerrain(ctx, width, height) {
            // Sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.3);
            skyGradient.addColorStop(0, '#87ceeb');
            skyGradient.addColorStop(1, '#b0e0e6');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, width, height * 0.3);
            
            // Mountains silhouette
            ctx.fillStyle = '#696969';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.moveTo(0, height * 0.4);
            ctx.lineTo(width * 0.15, height * 0.15);
            ctx.lineTo(width * 0.3, height * 0.25);
            ctx.lineTo(width * 0.45, height * 0.1);
            ctx.lineTo(width * 0.6, height * 0.2);
            ctx.lineTo(width * 0.75, height * 0.15);
            ctx.lineTo(width * 0.9, height * 0.23);
            ctx.lineTo(width, height * 0.18);
            ctx.lineTo(width, height * 0.4);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1.0;
            
            // Hills
            ctx.fillStyle = '#9acd32';
            ctx.globalAlpha = 0.7;
            for (let i = 0; i < width; i += 36) {
                const hillHeight = 12 + Math.sin(i * 0.01) * 6;
                ctx.beginPath();
                ctx.ellipse(i + 18, height * 0.4 - hillHeight/2, 27, hillHeight, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
            
            // Plains
            ctx.fillStyle = '#228b22';
            ctx.fillRect(0, height * 0.4, width, height * 0.6);
            
            // Grass patches
            ctx.fillStyle = '#32cd32';
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * width;
                const y = height * 0.4 + Math.random() * height * 0.5;
                const size = 3 + Math.random() * 6;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;
        }

        function drawMiniMapFeatures(ctx, width, height) {
            // Main paths
            ctx.strokeStyle = '#8b4513';
            ctx.globalAlpha = 0.7;
            ctx.lineWidth = 2;
            
            // Vertical main road
            ctx.beginPath();
            ctx.moveTo(width * 0.475, height * 0.48);
            ctx.lineTo(width * 0.475, height);
            ctx.stroke();
            
            // Horizontal cross road
            ctx.beginPath();
            ctx.moveTo(width * 0.2, height * 0.6);
            ctx.lineTo(width * 0.8, height * 0.6);
            ctx.stroke();
            
            ctx.globalAlpha = 1.0;
            
            // Water features
            // Pond
            ctx.fillStyle = '#4169e1';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.ellipse(width * 0.75, height * 0.27, 7, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#87ceeb';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.ellipse(width * 0.75, height * 0.27, 6, 4, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Stream (simplified)
            ctx.strokeStyle = '#4169e1';
            ctx.globalAlpha = 0.8;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(width * 0.75, height * 0.31);
            ctx.quadraticCurveTo(width * 0.6, height * 0.45, width * 0.5, height * 0.53);
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            
            // Trees (simplified dots)
            const treePositions = [
                {x: 0.4, y: 0.47}, {x: 0.6, y: 0.47}, {x: 0.5, y: 0.33},
                {x: 0.3, y: 0.6}, {x: 0.7, y: 0.6}, {x: 0.25, y: 0.4}
            ];
            
            ctx.fillStyle = '#228b22';
            treePositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(width * pos.x, height * pos.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Rocks (tiny gray dots)
            const rockPositions = [
                {x: 0.3, y: 0.53}, {x: 0.7, y: 0.57}, {x: 0.4, y: 0.2}, 
                {x: 0.8, y: 0.47}, {x: 0.2, y: 0.4}, {x: 0.9, y: 0.33}
            ];
            
            ctx.fillStyle = '#696969';
            rockPositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(width * pos.x, height * pos.y, 1, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Flower patches (colored dots)
            const flowerPatches = [
                {x: 0.35, y: 0.43, color: '#ff69b4'}, // Pink
                {x: 0.6, y: 0.37, color: '#ff4500'}, // Orange  
                {x: 0.7, y: 0.5, color: '#9370db'} // Purple
            ];
            
            flowerPatches.forEach(patch => {
                ctx.fillStyle = patch.color;
                ctx.beginPath();
                ctx.arc(width * patch.x, height * patch.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawMiniMapEntities(ctx, width, height) {
            // Draw dragons if any exist
            if (typeof wanderingDragons !== 'undefined' && wanderingDragons.length > 0) {
                ctx.fillStyle = '#ff6b35';
                wanderingDragons.forEach(dragon => {
                    if (dragon && dragon.x && dragon.y) {
                        const miniX = (dragon.x / 2000) * width;
                        const miniY = height - (dragon.y / 1500) * height;
                        ctx.beginPath();
                        ctx.arc(miniX, miniY, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Glow effect
                        ctx.shadowColor = '#ff6b35';
                        ctx.shadowBlur = 3;
                        ctx.beginPath();
                        ctx.arc(miniX, miniY, 1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                });
            }
            
            // Draw monsters if any exist
            if (typeof wanderingMonsters !== 'undefined' && wanderingMonsters.length > 0) {
                ctx.fillStyle = '#8b0000';
                wanderingMonsters.forEach(monster => {
                    if (monster && monster.x && monster.y) {
                        const miniX = (monster.x / 2000) * width;
                        const miniY = height - (monster.y / 1500) * height;
                        ctx.fillRect(miniX - 1, miniY - 1, 2, 2);
                    }
                });
            }
        }

        function toggleMiniMapLegend() {
            const legend = document.getElementById('miniMapLegend');
            if (legend.style.display === 'none' || legend.style.display === '') {
                legend.style.display = 'block';
                setTimeout(() => {
                    legend.style.display = 'none';
                }, 3000); // Auto-hide after 3 seconds
            } else {
                legend.style.display = 'none';
            }
        }

        function centerCamera() {
            updateCamera();
            cameraPosition.x = targetCameraPosition.x;
            cameraPosition.y = targetCameraPosition.y;
            
            const worldContainer = document.getElementById('worldContainer');
            if (worldContainer) {
                worldContainer.style.transform = `translate(${-cameraPosition.x}px, ${-cameraPosition.y}px) scale(${currentZoom})`;
            }
            
            updateMiniMap();
        }

        // UI Functions
        function updateStatus(message) {
            const statusBar = document.getElementById('statusBar');
            if (statusBar) {
                statusBar.textContent = message;
            }
        }

        function toggleInventory() {
            const panel = document.getElementById('inventoryPanel');
            if (panel) {
                closeAllPanels();
                if (panel.style.display !== 'block') {
                    panel.style.display = 'block';
                    updateStatus('Inventory opened');
                }
            }
        }

        function toggleDragonCare() {
            const panel = document.getElementById('dragonCarePanel');
            if (panel) {
                closeAllPanels();
                if (panel.style.display !== 'block') {
                    panel.style.display = 'block';
                    initializeDragonCareSprite();
                    updateStatus('Dragon care panel opened');
                }
            }
        }
        
        function initializeDragonCareSprite() {
            // Only initialize once
            if (dragonCareApp) return;
            
            const container = document.getElementById('dragonSpriteContainer');
            if (!container) return;
            
            // Create a new PixiJS app for the dragon care panel
            dragonCareApp = new PIXI.Application({
                width: 150,
                height: 150,
                backgroundColor: 0xf0f8ff,
                antialias: true
            });
            
            // Clear container and add canvas
            container.innerHTML = '';
            container.appendChild(dragonCareApp.view);
            
            // Create dragon sprite for care panel
            createDragonCareSprite();
            
            // Start animation loop for the care panel dragon
            dragonCareApp.ticker.add(() => {
                animateDragonCareSprite();
            });
        }
        
        function createDragonCareSprite() {
            if (!dragonCareApp) return;
            
            // Create a simplified version of the dragon sprite
            const dragonContainer = new PIXI.Container();
            const scale = 1.5; // Smaller scale for panel
            
            // Dragon body
            const body = new PIXI.Graphics();
            body.beginFill(dragonStats.traits.bodyColor);
            body.drawEllipse(0, 0, 25 * scale, 20 * scale);
            body.endFill();
            
            // Dragon head
            const head = new PIXI.Graphics();
            head.beginFill(dragonStats.traits.bodyColor);
            head.drawEllipse(-20 * scale, -5 * scale, 15 * scale, 12 * scale);
            head.endFill();
            
            // Eyes
            const eyes = new PIXI.Graphics();
            eyes.beginFill(dragonStats.traits.eyeColor);
            eyes.drawCircle(-25 * scale, -8 * scale, 2 * scale);
            eyes.drawCircle(-20 * scale, -8 * scale, 2 * scale);
            eyes.endFill();
            
            // Wings (if has wings)
            if (dragonStats.traits.hasWings) {
                const leftWing = new PIXI.Graphics();
                leftWing.beginFill(dragonStats.traits.wingColor, 0.8);
                leftWing.drawPolygon([
                    5 * scale, -5 * scale,
                    25 * scale, -15 * scale,
                    25 * scale, 5 * scale,
                    10 * scale, 5 * scale
                ]);
                leftWing.endFill();
                
                const rightWing = new PIXI.Graphics();
                rightWing.beginFill(dragonStats.traits.wingColor, 0.8);
                rightWing.drawPolygon([
                    5 * scale, -5 * scale,
                    25 * scale, -15 * scale,
                    25 * scale, 5 * scale,
                    10 * scale, 5 * scale
                ]);
                rightWing.scale.x = -1;
                rightWing.endFill();
                
                dragonContainer.addChild(leftWing);
                dragonContainer.addChild(rightWing);
            }
            
            // Horns (if has horns)
            if (dragonStats.traits.hasHorns) {
                const horns = new PIXI.Graphics();
                horns.beginFill(dragonStats.traits.accentColor);
                horns.drawPolygon([
                    -22 * scale, -12 * scale,
                    -20 * scale, -6 * scale,
                    -18 * scale, -12 * scale
                ]);
                horns.drawPolygon([
                    -16 * scale, -12 * scale,
                    -14 * scale, -6 * scale,
                    -12 * scale, -12 * scale
                ]);
                horns.endFill();
                dragonContainer.addChild(horns);
            }
            
            // Tail
            const tail = new PIXI.Graphics();
            tail.beginFill(dragonStats.traits.bodyColor);
            tail.moveTo(15 * scale, 0);
            tail.bezierCurveTo(
                25 * scale, 5 * scale,
                30 * scale, -5 * scale,
                35 * scale, 0
            );
            tail.lineStyle(6 * scale, dragonStats.traits.bodyColor);
            tail.endFill();
            
            // Add all parts to container
            dragonContainer.addChild(tail);
            dragonContainer.addChild(body);
            dragonContainer.addChild(head);
            dragonContainer.addChild(eyes);
            
            // Position in center of canvas
            dragonContainer.x = 75;
            dragonContainer.y = 75;
            
            dragonCareSprite = dragonContainer;
            dragonCareApp.stage.addChild(dragonCareSprite);
        }
        
        function animateDragonCareSprite() {
            if (!dragonCareSprite) return;
            
            const time = Date.now() * 0.001;
            
            // Gentle breathing animation
            const breathScale = 1 + Math.sin(time * 2) * 0.05;
            dragonCareSprite.scale.set(breathScale);
            
            // Slight rotation animation
            dragonCareSprite.rotation = Math.sin(time * 1.5) * 0.05;
        }
        
        function updateDragonCareEmotion(emotion) {
            if (!dragonCareSprite) return;
            
            // Find and update eye color based on emotion
            const children = dragonCareSprite.children;
            for (let child of children) {
                // Check if this is the eyes element (should be one of the last added)
                if (child.geometry && child.fill && child.fill.color) {
                    // This is likely the eyes - update color
                    const eyeColor = getEmotionEyeColor(emotion);
                    child.clear();
                    child.beginFill(eyeColor);
                    const scale = 1.5;
                    child.drawCircle(-25 * scale, -8 * scale, 2 * scale);
                    child.drawCircle(-20 * scale, -8 * scale, 2 * scale);
                    child.endFill();
                    break;
                }
            }
            
            // Add emotion particles
            if (emotion === 'happy') {
                showEmotionParticles('‚ù§Ô∏è');
            } else if (emotion === 'sad') {
                showEmotionParticles('üíß');
            } else if (emotion === 'hungry') {
                showEmotionParticles('üçñ');
            }
        }
        
        function showEmotionParticles(emoji) {
            if (!dragonCareApp) return;
            
            // Create temporary emotion particle
            const particle = new PIXI.Text(emoji, {
                fontSize: 20,
                fill: 0xFFFFFF
            });
            
            particle.x = 75 + (Math.random() - 0.5) * 40;
            particle.y = 50;
            particle.alpha = 1;
            
            dragonCareApp.stage.addChild(particle);
            
            // Animate particle floating up and fading
            let frame = 0;
            const ticker = dragonCareApp.ticker.add(() => {
                particle.y -= 1;
                particle.alpha -= 0.02;
                
                if (particle.alpha <= 0) {
                    dragonCareApp.stage.removeChild(particle);
                    dragonCareApp.ticker.remove(ticker);
                }
            });
        }

        function toggleBattle() {
            const panel = document.getElementById('battlePanel');
            if (panel) {
                closeAllPanels();
                if (panel.style.display !== 'block') {
                    panel.style.display = 'block';
                    updateStatus('Battle panel opened');
                }
            }
        }

        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            if (panel) {
                closeAllPanels();
                if (panel.style.display !== 'block') {
                    panel.style.display = 'block';
                    updateStatus('Settings panel opened');
                }
            }
        }

        function closeAllPanels() {
            const panels = ['inventoryPanel', 'dragonCarePanel', 'battlePanel', 'settingsPanel'];
            panels.forEach(id => {
                const panel = document.getElementById(id);
                if (panel) panel.style.display = 'none';
            });
        }

        function closeInventory() {
            document.getElementById('inventoryPanel').style.display = 'none';
        }

        function closeDragonCare() {
            document.getElementById('dragonCarePanel').style.display = 'none';
        }

        function closeBattle() {
            document.getElementById('battlePanel').style.display = 'none';
        }

        function closeSettings() {
            document.getElementById('settingsPanel').style.display = 'none';
        }

        function closePopup() {
            document.getElementById('locationPopup').style.display = 'none';
        }

        // Zoom functions
        function zoomIn() {
            currentZoom = Math.min(2.0, currentZoom + 0.2);
            updateCamera();
        }

        function zoomOut() {
            currentZoom = Math.max(0.5, currentZoom - 0.2);
            updateCamera();
        }

        function resetZoom() {
            currentZoom = 1.0;
            updateCamera();
        }

        // Save/Load functions
        function saveGame() {
            try {
                const gameData = {
                    playerPosition: playerPosition,
                    timestamp: Date.now()
                };
                localStorage.setItem('dragonHatchersGame', JSON.stringify(gameData));
                updateStatus('Game saved successfully!');
            } catch (error) {
                updateStatus('Failed to save game!');
            }
        }

        function loadGame() {
            try {
                const savedData = localStorage.getItem('dragonHatchersGame');
                if (savedData) {
                    const gameData = JSON.parse(savedData);
                    playerPosition = gameData.playerPosition || { x: 1000, y: 650 };
                    
                    // Update player sprite position
                    if (playerSprite) {
                        playerSprite.x = playerPosition.x;
                        playerSprite.y = 1500 - playerPosition.y;
                    }
                    
                    centerCamera();
                    updateStatus('Game loaded successfully!');
                } else {
                    updateStatus('No saved game found!');
                }
            } catch (error) {
                updateStatus('Failed to load game!');
            }
        }
        
        function handleWorldInteraction(clickX, clickY) {
            // Convert click to world coordinates
            const worldX = clickX;
            const worldY = 1500 - clickY;
            
            console.log('Checking interaction at:', worldX, worldY);
            
            // Check distance from player
            const distToPlayer = Math.sqrt(
                Math.pow(worldX - playerPosition.x, 2) + 
                Math.pow(worldY - playerPosition.y, 2)
            );
            
            if (distToPlayer > 100) {
                updateStatus('Too far away to interact!');
                return;
            }
            
            // Check trees
            for (let tree of worldObjects.trees) {
                if (Math.abs(tree.x - worldX) < 30 && Math.abs(tree.y - worldY) < 40) {
                    playerInventory.wood += Math.floor(Math.random() * 3) + 1;
                    updateInventoryPanel();
                    updateStatus('You chop some wood from the tree! üå≥');
                    flashObject(tree.sprite);
                    return;
                }
            }
            
            // Check sheep
            for (let sheep of worldObjects.sheep) {
                if (Math.abs(sheep.x - worldX) < 25 && Math.abs(sheep.y - worldY) < 20) {
                    updateStatus('The sheep says: Baa! üêë');
                    animateSheep(sheep.sprite);
                    return;
                }
            }
            
            // Check wandering dragons
            for (let dragon of worldObjects.wanderingDragons) {
                if (Math.abs(dragon.x - worldX) < 35 && Math.abs(dragon.y - worldY) < 30) {
                    handleWanderingDragonInteraction(dragon);
                    return;
                }
            }
            
            // Check structures
            for (let structure of worldObjects.structures) {
                if (Math.abs(structure.x - worldX) < 40 && Math.abs(structure.y - worldY) < 35) {
                    if (structure.type === 'house') {
                        updateStatus('You enter the house and rest. Health restored! üè†');
                        dragonStats.health = Math.min(100, dragonStats.health + 20);
                        updateDragonPanel();
                    } else if (structure.type === 'cave') {
                        updateStatus('You explore the dark cave... Found treasure! üíé');
                        playerInventory.gold += 25;
                        updateInventoryPanel();
                    }
                    flashObject(structure.sprite);
                    return;
                }
            }
            
            // Check monsters for battle
            for (let monster of worldObjects.monsters) {
                if (Math.abs(monster.x - worldX) < 25 && Math.abs(monster.y - worldY) < 25) {
                    if (monster.health > 0) {
                        startBattle(monster);
                        return;
                    } else {
                        updateStatus('The ' + monster.type + ' has already been defeated.');
                        return;
                    }
                }
            }
            
            updateStatus('Nothing to interact with here.');
        }
        
        function handleWanderingDragonInteraction(dragon) {
            flashObject(dragon.sprite);
            
            if (dragon.type === 'ancient') {
                // Ancient dragon gives wisdom and experience
                const wisdom = [
                    "The ancient dragon shares ancient knowledge about dragon care with you.",
                    "The wise ancient dragon teaches you secrets of dragon bonding.",
                    "The ancient dragon bestows a blessing upon your companion dragon."
                ];
                const randomWisdom = wisdom[Math.floor(Math.random() * wisdom.length)];
                updateStatus(randomWisdom);
                
                dragonStats.experience += 25;
                updateDragonPanel();
            } else {
                // Regular wandering dragons
                const personalityResponses = {
                    friendly: [
                        `The friendly ${dragon.type} dragon wags its tail happily and nuzzles you gently.`,
                        `This ${dragon.type} dragon seems delighted to see you! It performs a little dance.`,
                        `The ${dragon.type} dragon chirps cheerfully and offers to share its treasure.`
                    ],
                    fierce: [
                        `The fierce ${dragon.type} dragon eyes you warily, smoke rising from its nostrils.`,
                        `This ${dragon.type} dragon stands its ground, challenging you with a mighty roar.`,
                        `The ${dragon.type} dragon flares its wings intimidatingly, but doesn't attack.`
                    ],
                    calm: [
                        `The serene ${dragon.type} dragon regards you peacefully, its eyes full of wisdom.`,
                        `This ${dragon.type} dragon nods slowly in acknowledgment of your presence.`,
                        `The ${dragon.type} dragon hums a low, melodic tune that soothes your soul.`
                    ],
                    stoic: [
                        `The stoic ${dragon.type} dragon observes you silently, unmoved by your presence.`,
                        `This ${dragon.type} dragon simply stares at you with ancient, knowing eyes.`,
                        `The ${dragon.type} dragon gives you a single, respectful nod.`
                    ],
                    mysterious: [
                        `The enigmatic ${dragon.type} dragon seems to fade in and out of view.`,
                        `This ${dragon.type} dragon whispers secrets in an ancient draconic language.`,
                        `The ${dragon.type} dragon's eyes glow with otherworldly knowledge.`
                    ]
                };
                
                const responses = personalityResponses[dragon.personality] || personalityResponses.calm;
                const randomResponse = responses[Math.floor(Math.random() * responses.length)];
                updateStatus(randomResponse);
                
                // Small chance of getting a gift
                if (Math.random() < 0.3) {
                    playerInventory.gold += Math.floor(Math.random() * 10) + 5;
                    updateInventoryPanel();
                    updateStatus('The ' + dragon.type + ' dragon left you a small gift! ‚ú®');
                }
            }
        }
        
        function flashObject(sprite) {
            if (!sprite) return;
            
            const originalAlpha = sprite.alpha;
            sprite.alpha = 0.5;
            setTimeout(() => {
                sprite.alpha = originalAlpha;
            }, 200);
        }
        
        function animateSheep(sprite) {
            if (!sprite) return;
            
            const originalY = sprite.y;
            sprite.y -= 20;
            setTimeout(() => {
                sprite.y = originalY;
            }, 300);
        }
        
        function updatePlayerDirection() {
            if (!playerSprite || !playerSprite.bodyParts) return;
            
            const { eyes, leftArm, rightArm } = playerSprite.bodyParts;
            
            // Clear previous eyes and redraw based on direction
            eyes.clear();
            eyes.beginFill(0x000000);
            
            switch(playerDirection) {
                case 'up':
                    // Eyes looking up
                    eyes.drawCircle(-2, -20, 1.5);
                    eyes.drawCircle(2, -20, 1.5);
                    break;
                case 'down':
                    // Eyes looking down/forward
                    eyes.drawCircle(-3, -18, 1.5);
                    eyes.drawCircle(3, -18, 1.5);
                    break;
                case 'left':
                    // Eyes looking left
                    eyes.drawCircle(-4, -18, 1.5);
                    eyes.drawCircle(0, -18, 1.5);
                    // Adjust arms for side view
                    leftArm.x = -2;
                    rightArm.x = 2;
                    break;
                case 'right':
                    // Eyes looking right
                    eyes.drawCircle(0, -18, 1.5);
                    eyes.drawCircle(4, -18, 1.5);
                    // Adjust arms for side view
                    leftArm.x = -2;
                    rightArm.x = 2;
                    break;
                default:
                    // Default front-facing
                    eyes.drawCircle(-3, -18, 1.5);
                    eyes.drawCircle(3, -18, 1.5);
                    leftArm.x = 0;
                    rightArm.x = 0;
            }
            
            eyes.endFill();
            
            // Add slight body rotation for left/right movement
            if (playerDirection === 'left') {
                playerSprite.scale.x = -1; // Flip horizontally
            } else if (playerDirection === 'right') {
                playerSprite.scale.x = 1; // Normal orientation
            }
        }
        
        // On-screen movement controls
        function startMove(direction) {
            switch(direction) {
                case 'up':
                    keysPressed['KeyW'] = true;
                    break;
                case 'down':
                    keysPressed['KeyS'] = true;
                    break;
                case 'left':
                    keysPressed['KeyA'] = true;
                    break;
                case 'right':
                    keysPressed['KeyD'] = true;
                    break;
                case 'up-left':
                    keysPressed['KeyW'] = true;
                    keysPressed['KeyA'] = true;
                    break;
                case 'up-right':
                    keysPressed['KeyW'] = true;
                    keysPressed['KeyD'] = true;
                    break;
                case 'down-left':
                    keysPressed['KeyS'] = true;
                    keysPressed['KeyA'] = true;
                    break;
                case 'down-right':
                    keysPressed['KeyS'] = true;
                    keysPressed['KeyD'] = true;
                    break;
            }
            
            if (!isMoving) {
                startMovement();
            }
        }
        
        function stopMove(direction) {
            switch(direction) {
                case 'up':
                    delete keysPressed['KeyW'];
                    break;
                case 'down':
                    delete keysPressed['KeyS'];
                    break;
                case 'left':
                    delete keysPressed['KeyA'];
                    break;
                case 'right':
                    delete keysPressed['KeyD'];
                    break;
                case 'up-left':
                    delete keysPressed['KeyW'];
                    delete keysPressed['KeyA'];
                    break;
                case 'up-right':
                    delete keysPressed['KeyW'];
                    delete keysPressed['KeyD'];
                    break;
                case 'down-left':
                    delete keysPressed['KeyS'];
                    delete keysPressed['KeyA'];
                    break;
                case 'down-right':
                    delete keysPressed['KeyS'];
                    delete keysPressed['KeyD'];
                    break;
            }
            
            if (Object.keys(keysPressed).length === 0) {
                stopMovement();
            }
        }
        
        // Prevent context menu on touch devices
        document.addEventListener('contextmenu', function(e) {
            if (e.target.classList.contains('move-btn')) {
                e.preventDefault();
            }
        });
        
        function updateSheepAnimations() {
            if (!worldObjects.sheep) return;
            
            worldObjects.sheep.forEach(sheep => {
                sheep.animations.timer++;
                
                switch(sheep.animations.state) {
                    case 'idle':
                        updateSheepIdle(sheep);
                        break;
                    case 'grazing':
                        updateSheepGrazing(sheep);
                        break;
                    case 'walking':
                        updateSheepWalking(sheep);
                        break;
                }
                
                // Add subtle breathing animation
                const time = Date.now() * 0.001;
                const breathScale = 1 + Math.sin(time * 2 + sheep.x * 0.01) * 0.02;
                sheep.sprite.scale.y = breathScale;
            });
        }
        
        function updateWanderingDragons() {
            if (!worldObjects.wanderingDragons) return;
            
            worldObjects.wanderingDragons.forEach(dragon => {
                dragon.animations.timer++;
                dragon.animations.breatheTimer++;
                
                // Wandering AI
                if (dragon.animations.timer > (dragon.type === 'ancient' ? 300 : 150)) {
                    dragon.animations.timer = 0;
                    
                    // Randomly change direction or pause
                    if (Math.random() < 0.7) {
                        dragon.animations.direction += (Math.random() - 0.5) * 1.5;
                    }
                    
                    // Ancient dragon moves less frequently
                    if (dragon.type === 'ancient' && Math.random() < 0.4) {
                        dragon.animations.speed = 0; // Sometimes just sits majestically
                        setTimeout(() => {
                            if (dragon.animations) dragon.animations.speed = 0.3;
                        }, 2000);
                    }
                }
                
                // Movement within territory
                const moveDistance = dragon.animations.speed;
                const newX = dragon.x + Math.cos(dragon.animations.direction) * moveDistance;
                const newY = dragon.y + Math.sin(dragon.animations.direction) * moveDistance;
                
                // Check territory bounds
                const distFromHome = Math.sqrt(
                    Math.pow(newX - dragon.animations.homeX, 2) + 
                    Math.pow(newY - dragon.animations.homeY, 2)
                );
                
                if (distFromHome > dragon.animations.wanderRadius) {
                    // Return towards home
                    dragon.animations.direction = Math.atan2(
                        dragon.animations.homeY - dragon.y,
                        dragon.animations.homeX - dragon.x
                    ) + (Math.random() - 0.5) * 0.5;
                }
                
                // Update position
                const clampedX = Math.max(100, Math.min(1900, newX));
                const clampedY = Math.max(100, Math.min(1400, newY));
                
                dragon.x = clampedX;
                dragon.y = clampedY;
                dragon.sprite.x = clampedX;
                dragon.sprite.y = 1500 - clampedY;
                
                // Face movement direction
                const dx = Math.cos(dragon.animations.direction);
                if (Math.abs(dx) > 0.1) {
                    const originalScaleX = Math.abs(dragon.sprite.scale.x);
                    dragon.sprite.scale.x = dx > 0 ? -originalScaleX : originalScaleX;
                }
                
                // Refined animations aligned with companion dragon style
                const time = Date.now() * 0.001;
                
                // Size-based animation speed scaling (bigger dragons = slower animations)
                const sizeSpeedMultiplier = 1 / Math.max(dragon.size, 0.5); // Inverse scaling
                const scaledTime = time * sizeSpeedMultiplier;
                
                // Animate individual body parts using companion dragon style
                if (dragon.sprite.bodyParts) {
                    // Breathing animation (body scale only, like companion)
                    const breathScale = 1 + Math.sin(scaledTime * 2) * 0.05;
                    dragon.sprite.bodyParts.body.scale.y = breathScale;
                    
                    // Tail sway (much more subtle, like companion)
                    if (dragon.sprite.bodyParts.tail) {
                        dragon.sprite.bodyParts.tail.rotation = Math.sin(scaledTime * 1.5) * 0.3;
                    }
                    
                    // Wing flapping (aligned with companion dragon style)
                    if (dragon.sprite.bodyParts.wings) {
                        const wingFlap = Math.sin(scaledTime * 4) * 0.2;
                        dragon.sprite.bodyParts.wings[0].rotation = -0.2 + wingFlap;
                        dragon.sprite.bodyParts.wings[1].rotation = 0.2 - wingFlap;
                        
                        // Subtle fly bobbing for winged dragons
                        const flyBob = Math.sin(scaledTime * 3) * 3;
                        dragon.sprite.y += flyBob * 0.1;
                    }
                    
                    // Leg animation when moving (like companion dragon)
                    if (dragon.sprite.bodyParts.legs && dragon.animations.speed > 0) {
                        const legBob = Math.sin(scaledTime * 6) * 0.1;
                        dragon.sprite.bodyParts.legs[0].y = 12 * dragon.size + legBob;
                        dragon.sprite.bodyParts.legs[2].y = 12 * dragon.size + legBob;
                        dragon.sprite.bodyParts.legs[1].y = 12 * dragon.size - legBob;
                        dragon.sprite.bodyParts.legs[3].y = 12 * dragon.size - legBob;
                    } else if (dragon.sprite.bodyParts.legs) {
                        // Reset leg positions when not moving
                        dragon.sprite.bodyParts.legs.forEach(leg => {
                            leg.y = 12 * dragon.size;
                        });
                    }
                    
                    // Eye blinking (like companion dragon, but size-scaled timing)
                    const blinkInterval = 180 * Math.max(dragon.size, 1); // Bigger dragons blink slower
                    dragon.animations.blinkTimer += 1;
                    if (dragon.animations.blinkTimer > blinkInterval) {
                        dragon.animations.blinkTimer = 0;
                        if (dragon.sprite.bodyParts.eyes) {
                            dragon.sprite.bodyParts.eyes.alpha = 0.3;
                            setTimeout(() => {
                                if (dragon.sprite.bodyParts.eyes) {
                                    dragon.sprite.bodyParts.eyes.alpha = 1;
                                }
                            }, 150);
                        }
                    }
                }
            });
        }
        
        function updateWanderingMonsters() {
            if (!worldObjects.monsters) return;
            
            worldObjects.monsters.forEach(monster => {
                monster.animations.timer++;
                
                // Handle pause behavior
                if (monster.animations.isPaused) {
                    monster.animations.pauseTimer--;
                    if (monster.animations.pauseTimer <= 0) {
                        monster.animations.isPaused = false;
                    }
                    return; // Skip movement while paused
                }
                
                // Change direction/behavior every 120-240 frames
                if (monster.animations.timer > 120 + Math.random() * 120) {
                    monster.animations.timer = 0;
                    
                    // 30% chance to pause
                    if (Math.random() < 0.3) {
                        monster.animations.isPaused = true;
                        monster.animations.pauseTimer = 30 + Math.random() * 90;
                        return;
                    }
                    
                    // Change direction randomly
                    monster.animations.direction += (Math.random() - 0.5) * 2;
                    
                    // Adjust speed based on monster archetype
                    if (monster.archetype === 'beast') {
                        monster.animations.speed = 0.3 + Math.random() * 0.4; // Beasts move faster
                    } else if (monster.archetype === 'magical') {
                        monster.animations.speed = 0.1 + Math.random() * 0.2; // Magical creatures glide slowly
                    } else {
                        monster.animations.speed = 0.2 + Math.random() * 0.3; // Humanoids normal speed
                    }
                }
                
                // Calculate movement
                const moveDistance = monster.animations.speed;
                const newX = monster.x + Math.cos(monster.animations.direction) * moveDistance;
                const newY = monster.y + Math.sin(monster.animations.direction) * moveDistance;
                
                // Clamp to world bounds with some padding
                const clampedX = Math.max(100, Math.min(1900, newX));
                const clampedY = Math.max(100, Math.min(1400, newY));
                
                // If hitting bounds, turn around
                if (newX !== clampedX || newY !== clampedY) {
                    monster.animations.direction += Math.PI + (Math.random() - 0.5) * 0.5;
                }
                
                // Update position
                monster.x = clampedX;
                monster.y = clampedY;
                monster.sprite.x = clampedX;
                monster.sprite.y = 1500 - clampedY;
                
                // Face movement direction
                const dx = Math.cos(monster.animations.direction);
                if (Math.abs(dx) > 0.1) {
                    monster.sprite.scale.x = dx > 0 ? -Math.abs(monster.sprite.scale.x) : Math.abs(monster.sprite.scale.x);
                }
                
                // Simple breathing animation
                const time = Date.now() * 0.001;
                const breathScale = 1 + Math.sin(time * 2 + monster.x * 0.01) * 0.02;
                if (monster.sprite.children && monster.sprite.children.length > 0) {
                    monster.sprite.children.forEach(child => {
                        if (child.scale) {
                            child.scale.y = child.originalScaleY ? child.originalScaleY * breathScale : breathScale;
                        }
                    });
                }
            });
        }
        
        function updateSheepIdle(sheep) {
            // Idle state: occasional head bob
            const time = Date.now() * 0.001;
            const headBob = Math.sin(time * 1.5 + sheep.x * 0.01) * 0.1;
            sheep.sprite.rotation = headBob * 0.05;
            
            // Randomly switch to grazing or walking
            if (sheep.animations.timer > 120 + Math.random() * 180) {
                sheep.animations.timer = 0;
                
                if (Math.random() < 0.6) {
                    sheep.animations.state = 'grazing';
                } else {
                    sheep.animations.state = 'walking';
                    sheep.animations.direction = Math.random() * Math.PI * 2;
                }
            }
        }
        
        function updateSheepGrazing(sheep) {
            // Grazing state: head down animation
            const time = Date.now() * 0.001;
            const grazeBob = Math.sin(time * 3 + sheep.x * 0.01) * 0.3;
            sheep.sprite.rotation = -0.2 + grazeBob * 0.1;
            
            // Slightly wider breathing when grazing
            const breathScale = 1 + Math.sin(time * 2.5 + sheep.x * 0.01) * 0.03;
            sheep.sprite.scale.y = breathScale;
            
            // Return to idle after grazing
            if (sheep.animations.timer > 90 + Math.random() * 120) {
                sheep.animations.timer = 0;
                sheep.animations.state = 'idle';
                sheep.sprite.rotation = 0;
            }
        }
        
        function updateSheepWalking(sheep) {
            // Walking state: move around home area
            const moveDistance = sheep.animations.speed;
            const newX = sheep.x + Math.cos(sheep.animations.direction) * moveDistance;
            const newY = sheep.y + Math.sin(sheep.animations.direction) * moveDistance;
            
            // Check if moving too far from home
            const distFromHome = Math.sqrt(
                Math.pow(newX - sheep.animations.homeX, 2) + 
                Math.pow(newY - sheep.animations.homeY, 2)
            );
            
            if (distFromHome > sheep.animations.wanderRadius) {
                // Turn towards home
                sheep.animations.direction = Math.atan2(
                    sheep.animations.homeY - sheep.y,
                    sheep.animations.homeX - sheep.x
                ) + (Math.random() - 0.5) * 0.5;
            } else {
                // Random direction changes
                if (Math.random() < 0.02) {
                    sheep.animations.direction += (Math.random() - 0.5) * 0.8;
                }
            }
            
            // Keep within world bounds
            const clampedX = Math.max(50, Math.min(1950, newX));
            const clampedY = Math.max(50, Math.min(1450, newY));
            
            // Update position
            sheep.x = clampedX;
            sheep.y = clampedY;
            sheep.sprite.x = clampedX;
            sheep.sprite.y = 1500 - clampedY;
            
            // Face movement direction
            if (Math.cos(sheep.animations.direction) < 0) {
                sheep.sprite.scale.x = -1; // Face left
            } else {
                sheep.sprite.scale.x = 1;  // Face right
            }
            
            // Walking animation - leg bobbing
            const time = Date.now() * 0.001;
            const walkBob = Math.sin(time * 6 + sheep.x * 0.1) * 0.05;
            sheep.sprite.y += walkBob;
            
            // Stop walking after some time
            if (sheep.animations.timer > 60 + Math.random() * 90) {
                sheep.animations.timer = 0;
                sheep.animations.state = Math.random() < 0.7 ? 'idle' : 'grazing';
                sheep.sprite.rotation = 0;
                sheep.sprite.scale.x = 1;
            }
        }
        
        // Dragon care system functions
        function updateDragonPanel() {
            document.getElementById('dragonHealth').textContent = Math.floor(dragonStats.health);
            document.getElementById('dragonHappiness').textContent = Math.floor(dragonStats.happiness);
            document.getElementById('dragonHunger').textContent = Math.floor(dragonStats.hunger);
            document.getElementById('dragonLevel').textContent = dragonStats.level;
            document.getElementById('dragonExp').textContent = dragonStats.experience;
            
            document.getElementById('healthBar').style.width = dragonStats.health + '%';
            document.getElementById('happinessBar').style.width = dragonStats.happiness + '%';
            document.getElementById('hungerBar').style.width = dragonStats.hunger + '%';
            
            document.getElementById('foodCount').textContent = playerInventory.food;
            document.getElementById('potionCount').textContent = playerInventory.potions;
            
            // Update dragon info
            const dragonTypeCapitalized = dragonStats.type.charAt(0).toUpperCase() + dragonStats.type.slice(1);
            document.getElementById('dragonNameType').textContent = `üê≤ ${dragonStats.name} (${dragonTypeCapitalized} Dragon)`;
            document.getElementById('dragonPersonality').textContent = `Personality: ${dragonStats.personality.charAt(0).toUpperCase() + dragonStats.personality.slice(1)}`;
            document.getElementById('dragonTraits').textContent = `Wings: ${dragonStats.traits.hasWings ? 'Yes' : 'No'}, Horns: ${dragonStats.traits.hasHorns ? 'Yes' : 'No'}, Tail: ${dragonStats.traits.tailType}`;
        }
        
        function showInventoryTab(tab) {
            // Hide all tabs
            const tabContents = document.querySelectorAll('.inventory-tab-content');
            tabContents.forEach(content => content.style.display = 'none');
            
            // Remove active class from all tabs
            const tabButtons = document.querySelectorAll('.tab-btn');
            tabButtons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab
            document.getElementById(tab + 'Inventory').style.display = 'block';
            document.getElementById(tab + 'Tab').classList.add('active');
        }

        function updateInventoryPanel() {
            updateInventorySlots();
            
            // Update header info
            document.getElementById('inventorySlots').textContent = `${playerInventory.usedSlots}/${playerInventory.maxSlots}`;
            document.getElementById('inventoryValue').textContent = getInventoryValue();
            
            // Update basic tab
            document.getElementById('goldAmount').textContent = playerInventory.gold;
            document.getElementById('woodAmount').textContent = playerInventory.wood;
            document.getElementById('foodAmount').textContent = playerInventory.food;
            document.getElementById('potionAmount').textContent = playerInventory.potions;
            
            // Update equipment tab
            updateEquipmentDisplay();
            
            // Update consumables tab
            updateConsumablesDisplay();
            
            // Update materials tab
            updateMaterialsDisplay();
        }

        function updateEquipmentDisplay() {
            let equipmentHtml = '';
            if (playerInventory.equipment && playerInventory.equipment.length > 0) {
                equipmentHtml = '<h4>‚öîÔ∏è Equipment:</h4>';
                playerInventory.equipment.forEach((item, index) => {
                    const rarity = item.rarity || 'common';
                    equipmentHtml += `
                        <div class="item-slot ${rarity}">
                            <span style="font-size: 16px;">${item.icon || '‚öîÔ∏è'}</span>
                            <div class="item-details">
                                <div class="item-name">${item.name}</div>
                                <div class="item-description">
                                    ${item.damage ? `+${item.damage} ATK ` : ''}
                                    ${item.defense ? `+${item.defense} DEF ` : ''}
                                    ${item.rarity ? `(${item.rarity})` : ''}
                                </div>
                            </div>
                            <div class="item-actions">
                                <button class="item-btn sell" onclick="sellEquipment(${index})">Sell</button>
                            </div>
                        </div>
                    `;
                });
            } else {
                equipmentHtml = '<p style="color: #9ca3af; text-align: center; margin: 20px;">No equipment found</p>';
            }
            document.getElementById('equipmentDisplay').innerHTML = equipmentHtml;
        }

        function updateConsumablesDisplay() {
            let consumablesHtml = '<h4>üíä Consumables:</h4>';
            let hasItems = false;
            
            Object.keys(playerInventory.consumables).forEach(key => {
                const count = playerInventory.consumables[key];
                if (count > 0) {
                    hasItems = true;
                    const item = consumableItems[key];
                    if (item) {
                        consumablesHtml += `
                            <div class="item-slot">
                                <span style="font-size: 16px;">${item.icon}</span>
                                <div class="item-details">
                                    <div class="item-name">${item.name} (${count})</div>
                                    <div class="item-description">${item.description}</div>
                                </div>
                                <div class="item-actions">
                                    <button class="item-btn" onclick="useConsumableItem('${key}')">Use</button>
                                    <button class="item-btn sell" onclick="sellConsumable('${key}')">Sell</button>
                                </div>
                            </div>
                        `;
                    }
                }
            });
            
            if (!hasItems) {
                consumablesHtml += '<p style="color: #9ca3af; text-align: center; margin: 20px;">No consumables available</p>';
            }
            
            document.getElementById('consumablesDisplay').innerHTML = consumablesHtml;
        }

        function updateMaterialsDisplay() {
            let materialsHtml = '<h4>‚õèÔ∏è Crafting Materials:</h4>';
            let hasItems = false;
            
            Object.keys(playerInventory.materials).forEach(key => {
                const count = playerInventory.materials[key];
                if (count > 0) {
                    hasItems = true;
                    const item = materialItems[key];
                    if (item) {
                        materialsHtml += `
                            <div class="item-slot">
                                <span style="font-size: 16px;">${item.icon}</span>
                                <div class="item-details">
                                    <div class="item-name">${item.name} (${count})</div>
                                    <div class="item-description">${item.description}</div>
                                </div>
                                <div class="item-actions">
                                    <button class="item-btn sell" onclick="sellMaterial('${key}')">Sell</button>
                                </div>
                            </div>
                        `;
                    }
                }
            });
            
            if (!hasItems) {
                materialsHtml += '<p style="color: #9ca3af; text-align: center; margin: 20px;">No materials collected</p>';
            }
            
            document.getElementById('materialsDisplay').innerHTML = materialsHtml;
        }

        function sellEquipment(index) {
            const item = playerInventory.equipment[index];
            if (item) {
                let sellValue = 0;
                sellValue += item.damage ? item.damage * 5 : 0;
                sellValue += item.defense ? item.defense * 8 : 0;
                sellValue = Math.max(sellValue, 1); // Minimum 1 gold
                
                playerInventory.gold += sellValue;
                playerInventory.equipment.splice(index, 1);
                updateInventoryPanel();
                updateStatus(`Sold ${item.name} for ${sellValue} gold! üí∞`);
            }
        }

        function sellConsumable(itemKey) {
            if (playerInventory.consumables[itemKey] > 0) {
                const item = consumableItems[itemKey];
                const sellValue = Math.floor(item.value * 0.6); // Sell for 60% of buy value
                
                playerInventory.gold += sellValue;
                playerInventory.consumables[itemKey]--;
                updateInventoryPanel();
                updateStatus(`Sold ${item.name} for ${sellValue} gold! üí∞`);
            }
        }

        function sellMaterial(itemKey) {
            if (playerInventory.materials[itemKey] > 0) {
                const item = materialItems[itemKey];
                const sellValue = item.value;
                
                playerInventory.gold += sellValue;
                playerInventory.materials[itemKey]--;
                updateInventoryPanel();
                updateStatus(`Sold ${item.name} for ${sellValue} gold! üí∞`);
            }
        }
        
        function feedDragon() {
            if (playerInventory.food > 0) {
                playerInventory.food--;
                dragonStats.hunger = Math.min(100, dragonStats.hunger + 30);
                dragonStats.happiness = Math.min(100, dragonStats.happiness + 10);
                updateDragonPanel();
                updateInventoryPanel();
                updateDragonCareEmotion('happy');
                updateStatus('You fed your dragon! It looks happier. üê≤');
            } else {
                updateStatus('No food available! Buy some first.');
            }
        }
        
        function playWithDragon() {
            dragonStats.happiness = Math.min(100, dragonStats.happiness + 25);
            dragonStats.hunger = Math.max(0, dragonStats.hunger - 5);
            updateDragonCareEmotion('happy');
            dragonStats.experience += 5;
            
            if (dragonStats.experience >= dragonStats.level * 100) {
                dragonStats.level++;
                dragonStats.experience = 0;
                
                // Increase dragon size with level
                const oldSize = dragonStats.traits.size;
                dragonStats.traits.size = 0.5 + (dragonStats.level * 0.1);
                
                // Recreate dragon sprite with new size
                if (dragonSprite) {
                    pixiContainer.removeChild(dragonSprite);
                    createDragonSprite();
                }
                
                updateStatus('Your dragon leveled up! üéâ Level ' + dragonStats.level + ' - Dragon grew bigger!');
            } else {
                updateStatus('You played with your dragon! It gained experience. üéæ');
            }
            
            updateDragonPanel();
        }
        
        function healDragon() {
            if (playerInventory.potions > 0) {
                playerInventory.potions--;
                dragonStats.health = 100;
                dragonStats.happiness = Math.min(100, dragonStats.happiness + 15);
                updateDragonPanel();
                updateInventoryPanel();
                updateDragonCareEmotion('happy');
                showEmotionParticles('‚ú®');
                updateStatus('You healed your dragon to full health! üíä');
            } else {
                updateStatus('No potions available! Buy some first.');
            }
        }
        
        function buyFood() {
            if (playerInventory.gold >= 10) {
                playerInventory.gold -= 10;
                playerInventory.food++;
                updateInventoryPanel();
                updateDragonPanel();
                updateStatus('Bought food for 10 gold. üçñ');
            } else {
                updateStatus('Not enough gold! Need 10 gold.');
            }
        }
        
        function buyPotion() {
            if (playerInventory.gold >= 20) {
                playerInventory.gold -= 20;
                playerInventory.potions++;
                updateInventoryPanel();
                updateDragonPanel();
                updateStatus('Bought potion for 20 gold. üíä');
            } else {
                updateStatus('Not enough gold! Need 20 gold.');
            }
        }
        
        function sellWood() {
            if (playerInventory.wood > 0) {
                const goldEarned = playerInventory.wood * 5;
                playerInventory.gold += goldEarned;
                playerInventory.wood = 0;
                updateInventoryPanel();
                updateStatus('Sold wood for ' + goldEarned + ' gold. üí∞');
            } else {
                updateStatus('No wood to sell! Chop some trees first.');
            }
        }

        function buyDragonTreats() {
            if (playerInventory.gold >= 15) {
                playerInventory.gold -= 15;
                addItemToInventory('consumables', 'dragonTreats', 1);
                updateInventoryPanel();
                updateStatus('Bought Dragon Treats for 15 gold! üçñ');
            } else {
                updateStatus('Not enough gold! Need 15 gold.');
            }
        }

        function buyHealingPowder() {
            if (playerInventory.gold >= 25) {
                playerInventory.gold -= 25;
                addItemToInventory('consumables', 'healingPowders', 1);
                updateInventoryPanel();
                updateStatus('Bought Healing Powder for 25 gold! üíä');
            } else {
                updateStatus('Not enough gold! Need 25 gold.');
            }
        }

        function buyStrengthPotion() {
            if (playerInventory.gold >= 30) {
                playerInventory.gold -= 30;
                addItemToInventory('consumables', 'strengthPotions', 1);
                updateInventoryPanel();
                updateStatus('Bought Strength Potion for 30 gold! üß™');
            } else {
                updateStatus('Not enough gold! Need 30 gold.');
            }
        }
        
        // Battle system functions
        function startBattle(monster) {
            battleState.inBattle = true;
            battleState.enemy = monster;
            battleState.dragonHP = dragonStats.health;
            battleState.dragonMaxHP = 100; // Max dragon health
            battleState.turn = 'player';
            battleState.specialAttackCooldown = 0;
            
            // Update UI
            document.getElementById('battleInfo').style.display = 'block';
            document.getElementById('noBattleInfo').style.display = 'none';
            
            // Update enemy info
            const monsterIcon = getMonsterIcon(monster.type, monster.archetype);
            let monsterName = monsterIcon + ' ' + monster.type.charAt(0).toUpperCase() + monster.type.slice(1);
            
            // Add equipment info to name if monster has equipment
            if (monster.equipment || monster.traits?.equipment) {
                const equipment = monster.equipment || monster.traits?.equipment;
                if (equipment.weapon) {
                    monsterName += ' ' + equipment.weapon.icon;
                }
                if (equipment.armor) {
                    monsterName += ' [Armored]';
                }
            }
            
            document.getElementById('enemyName').textContent = monsterName;
            document.getElementById('enemyHP').textContent = monster.health;
            document.getElementById('enemyMaxHP').textContent = monster.maxHealth;
            
            // Update dragon info (replacing player info)
            const dragonIcon = dragonStats.type === 'fire' ? 'üî•' : dragonStats.type === 'ice' ? '‚ùÑÔ∏è' : dragonStats.type === 'earth' ? 'üåç' : dragonStats.type === 'storm' ? '‚ö°' : 'üåô';
            document.getElementById('dragonBattleName').textContent = dragonIcon + ' ' + dragonStats.name;
            document.getElementById('playerHP').textContent = Math.floor(battleState.dragonHP);
            document.getElementById('playerMaxHP').textContent = battleState.dragonMaxHP;
            
            updateBattleUI();
            logBattleMessage('A wild ' + monster.type + ' appears!');
            logBattleMessage('Go, ' + dragonStats.name + '! Show them your power!');
            
            // Create battle sprites
            createBattleDragonSprite(dragonStats);
            createBattleMonsterSprite(monster);
            
            // Open battle panel
            toggleBattle();
            
            updateStatus('Battle started with ' + monster.type + '! ‚öîÔ∏è');
        }
        
        function updateBattleUI() {
            const dragonHealthPercent = (battleState.dragonHP / battleState.dragonMaxHP) * 100;
            const enemyHealthPercent = (battleState.enemy.health / battleState.enemy.maxHealth) * 100;
            
            document.getElementById('playerHealthBar').style.width = dragonHealthPercent + '%';
            document.getElementById('enemyHealthBar').style.width = enemyHealthPercent + '%';
            
            document.getElementById('playerHP').textContent = Math.floor(battleState.dragonHP);
            document.getElementById('enemyHP').textContent = Math.floor(battleState.enemy.health);
            
            // Update cooldown display
            const specialBtn = document.getElementById('specialAttackBtn');
            if (battleState.specialAttackCooldown > 0) {
                specialBtn.textContent = `Special Attack (${battleState.specialAttackCooldown})`;
                specialBtn.disabled = true;
            } else {
                const dragonType = dragonStats.type || 'fire';
                const special = dragonSpecialAttacks[dragonType];
                specialBtn.textContent = `${special.icon} ${special.name}`;
                specialBtn.disabled = false;
            }
        }
        
        function logBattleMessage(message) {
            const log = document.getElementById('battleLog');
            const p = document.createElement('p');
            p.textContent = message;
            p.style.margin = '2px 0';
            log.appendChild(p);
            log.scrollTop = log.scrollHeight;
        }
        
        function dragonAttack() {
            if (!battleState.inBattle || battleState.turn !== 'player') return;
            
            const baseDamage = 15 + dragonStats.level * 2;
            const damage = Math.floor(Math.random() * baseDamage) + baseDamage;
            battleState.enemy.health -= damage;
            logBattleMessage(dragonStats.name + ' attacks for ' + damage + ' damage!');
            
            // Animate attack
            animateAttack('dragon', 'monster', 'normal');
            
            if (battleState.enemy.health <= 0) {
                endBattle(true);
                return;
            }
            
            battleState.turn = 'enemy';
            if (battleState.specialAttackCooldown > 0) battleState.specialAttackCooldown--;
            setTimeout(enemyAttack, 1000);
            updateBattleUI();
        }
        
        function dragonDefend() {
            if (!battleState.inBattle || battleState.turn !== 'player') return;
            
            logBattleMessage(dragonStats.name + ' braces for impact!');
            battleState.defending = true;
            battleState.turn = 'enemy';
            if (battleState.specialAttackCooldown > 0) battleState.specialAttackCooldown--;
            setTimeout(enemyAttack, 1000);
        }
        
        function usePotion() {
            if (!battleState.inBattle || battleState.turn !== 'player') return;
            
            if (playerInventory.potions > 0) {
                playerInventory.potions--;
                const healing = 30;
                battleState.dragonHP = Math.min(battleState.dragonMaxHP, battleState.dragonHP + healing);
                logBattleMessage('You gave ' + dragonStats.name + ' a potion and healed ' + healing + ' HP!');
                updateInventoryPanel();
                updateBattleUI();
                
                battleState.turn = 'enemy';
                if (battleState.specialAttackCooldown > 0) battleState.specialAttackCooldown--;
                setTimeout(enemyAttack, 1000);
            } else {
                logBattleMessage('No potions available!');
            }
        }
        
        function dragonSpecialAttack() {
            if (!battleState.inBattle || battleState.turn !== 'player' || battleState.specialAttackCooldown > 0) return;
            
            const dragonType = dragonStats.type || 'fire';
            const special = dragonSpecialAttacks[dragonType];
            
            const damage = special.baseDamage + (dragonStats.level * 3);
            battleState.enemy.health -= damage;
            battleState.specialAttackCooldown = special.cooldown;
            
            logBattleMessage(dragonStats.name + ' uses ' + special.name + ' ' + special.icon + ' for ' + damage + ' damage!');
            
            // Animate special attack
            animateAttack('dragon', 'monster', dragonType);
            
            // Apply special effect
            if (special.effect === 'burn') {
                logBattleMessage('The enemy is burning! \ud83d\udd25');
            } else if (special.effect === 'freeze') {
                logBattleMessage('The enemy is frozen! \u2744\ufe0f');
            } else if (special.effect === 'drain') {
                const healAmount = Math.floor(damage * 0.3);
                battleState.dragonHP = Math.min(battleState.dragonMaxHP, battleState.dragonHP + healAmount);
                logBattleMessage(dragonStats.name + ' drains ' + healAmount + ' HP! \ud83c\udf19');
            }
            
            if (battleState.enemy.health <= 0) {
                endBattle(true);
                return;
            }
            
            battleState.turn = 'enemy';
            setTimeout(enemyAttack, 1000);
            updateBattleUI();
        }

        function fleeBattle() {
            if (!battleState.inBattle) return;
            
            if (Math.random() < 0.7) {
                logBattleMessage('You and ' + dragonStats.name + ' successfully fled from battle!');
                endBattle(false);
            } else {
                logBattleMessage('Could not escape!');
                battleState.turn = 'enemy';
                if (battleState.specialAttackCooldown > 0) battleState.specialAttackCooldown--;
                setTimeout(enemyAttack, 1000);
            }
        }

        function getMonsterIcon(type, archetype) {
            const icons = {
                // Humanoid
                goblin: '\ud83d\udc7a', orc: '\ud83d\udc79', hobgoblin: '\ud83d\udde1\ufe0f', dwarf: '\u26cf\ufe0f', human_bandit: '\ud83e\uddd9',
                skeleton: '\ud83d\udc80', zombie: '\ud83e\udddf',
                // Beast
                wolf: '\ud83d\udc3a', bear: '\ud83d\udc3b', wild_boar: '\ud83d\udc17', dire_wolf: '\ud83d\udc08', 
                shadow_cat: '\ud83d\udc08\u200d\u2b1b', giant_rat: '\ud83d\udc00',
                // Magical
                elemental: '\ud83d\udd25', wraith: '\ud83d\udc7b', imp: '\ud83d\udc7f', wisp: '\u2728', 
                golem: '\ud83e\udea8', sprite: '\ud83e\uddda'
            };
            return icons[type] || '\ud83d\udc7e';
        }
        
        function enemyAttack() {
            if (!battleState.inBattle || battleState.turn !== 'player') {
                let damage = Math.floor(Math.random() * battleState.enemy.attack) + 5;
                
                if (battleState.defending) {
                    damage = Math.floor(damage * 0.5);
                    battleState.defending = false;
                    logBattleMessage('The ' + battleState.enemy.type + ' attacks ' + dragonStats.name + ' for ' + damage + ' damage (reduced by defense)!');
                } else {
                    logBattleMessage('The ' + battleState.enemy.type + ' attacks ' + dragonStats.name + ' for ' + damage + ' damage!');
                }
                
                // Animate enemy attack
                animateAttack('monster', 'dragon', 'normal');
                
                battleState.dragonHP -= damage;
                
                if (battleState.dragonHP <= 0) {
                    endBattle(false);
                    return;
                }
                
                battleState.turn = 'player';
                updateBattleUI();
            }
        }
        
        function endBattle(dragonWon) {
            battleState.inBattle = false;
            
            // Persist dragon health to dragon care system
            dragonStats.health = Math.max(1, battleState.dragonHP);
            
            if (dragonWon) {
                const goldReward = Math.floor(Math.random() * 30) + 20;
                const expReward = Math.floor(Math.random() * 15) + 10;
                
                playerInventory.gold += goldReward;
                dragonStats.experience += expReward;
                
                // Enhanced loot system
                const enemy = battleState.enemy;
                const equipment = enemy.equipment || enemy.traits?.equipment;
                let lootMessage = '';
                
                // Equipment drops
                if (equipment) {
                    if (equipment.weapon && Math.random() < 0.3) {
                        if (!playerInventory.equipment) playerInventory.equipment = [];
                        playerInventory.equipment.push(equipment.weapon);
                        lootMessage += ' Found ' + equipment.weapon.name + ' ' + equipment.weapon.icon + '!';
                    }
                    if (equipment.armor && Math.random() < 0.2) {
                        if (!playerInventory.equipment) playerInventory.equipment = [];
                        playerInventory.equipment.push(equipment.armor);
                        lootMessage += ' Found ' + equipment.armor.name + '!';
                    }
                    if (equipment.helmet && Math.random() < 0.15) {
                        if (!playerInventory.equipment) playerInventory.equipment = [];
                        playerInventory.equipment.push(equipment.helmet);
                        lootMessage += ' Found ' + equipment.helmet.name + '!';
                    }
                }
                
                // Material drops based on enemy type
                if (enemy.archetype === 'humanoid') {
                    if (Math.random() < 0.4) {
                        addItemToInventory('materials', 'ironOre', 1 + Math.floor(Math.random() * 2));
                        lootMessage += ' Found Iron Ore!';
                    }
                } else if (enemy.archetype === 'beast') {
                    if (Math.random() < 0.3) {
                        addItemToInventory('materials', 'dragonScales', 1);
                        lootMessage += ' Found Dragon Scales!';
                    }
                } else if (enemy.archetype === 'magical') {
                    if (Math.random() < 0.5) {
                        addItemToInventory('materials', 'magicEssence', 1);
                        lootMessage += ' Found Magic Essence!';
                    }
                }
                
                // Rare gem chance for higher level enemies
                if (enemy.level >= 3 && Math.random() < 0.1) {
                    addItemToInventory('materials', 'rareGems', 1);
                    lootMessage += ' Found Rare Gem! ‚ú®';
                }
                
                // Consumable drops (small chance)
                if (Math.random() < 0.15) {
                    const consumableDrops = ['dragonTreats', 'healingPowders'];
                    const randomConsumable = consumableDrops[Math.floor(Math.random() * consumableDrops.length)];
                    addItemToInventory('consumables', randomConsumable, 1);
                    lootMessage += ` Found ${consumableItems[randomConsumable].name}!`;
                }
                
                // Remove defeated monster from world
                battleState.enemy.sprite.alpha = 0.3;
                
                logBattleMessage('Victory! ' + dragonStats.name + ' earned ' + goldReward + ' gold and ' + expReward + ' XP!' + lootMessage);
                updateStatus('Victory! ' + dragonStats.name + ' defeated the ' + battleState.enemy.type + '! üèÜ');
                
                if (dragonStats.experience >= dragonStats.level * 100) {
                    dragonStats.level++;
                    dragonStats.experience = 0;
                    dragonStats.health += 20; // Level up healing
                    logBattleMessage(dragonStats.name + ' leveled up! Level ' + dragonStats.level + ' (+20 HP)');
                }
            } else {
                if (battleState.dragonHP <= 0) {
                    logBattleMessage(dragonStats.name + ' was defeated! Returning home to recover...');
                    updateStatus(dragonStats.name + ' needs rest and care! üíî');
                    dragonStats.health = 10; // Minimal health after defeat
                    // Reset player position
                    playerPosition.x = 1000;
                    playerPosition.y = 650;
                    if (playerSprite) {
                        playerSprite.x = playerPosition.x;
                        playerSprite.y = 1500 - playerPosition.y;
                    }
                    centerCamera();
                }
            }
            
            battleState.specialAttackCooldown = 0; // Reset cooldown after battle
            updateInventoryPanel();
            updateDragonPanel();
            
            // Reset battle UI
            setTimeout(() => {
                document.getElementById('battleInfo').style.display = 'none';
                document.getElementById('noBattleInfo').style.display = 'block';
                document.getElementById('battleLog').innerHTML = '';
            }, 3000);
        }

        function createBattleDragonSprite(dragonData) {
            const container = document.getElementById('battleDragonSprite');
            container.innerHTML = '';
            
            // Create PixiJS application for battle dragon (same as companion)
            const battleDragonApp = new PIXI.Application({
                width: 80,
                height: 60,
                transparent: true,
                antialias: true
            });
            
            // Create dragon container using same structure as companion dragon
            const dragonContainer = new PIXI.Container();
            const scale = 0.8; // Slightly smaller for battle view
            
            // Dragon body (main torso) - same as companion dragon
            const body = new PIXI.Graphics();
            body.beginFill(dragonData.traits.bodyColor);
            body.drawEllipse(0, 0, 25 * scale, 15 * scale);
            body.endFill();
            
            // Dragon head - same as companion dragon
            const head = new PIXI.Graphics();
            head.beginFill(dragonData.traits.bodyColor);
            head.drawEllipse(-20 * scale, -5 * scale, 15 * scale, 12 * scale);
            head.endFill();
            
            // Dragon tail - same adaptive logic as companion dragon
            const tail = new PIXI.Graphics();
            tail.beginFill(dragonData.traits.bodyColor);
            if (dragonData.traits.tailType === 'spiked' || dragonData.traits.tailType === 'barbed') {
                // Spiked tail
                tail.moveTo(20 * scale, 0);
                tail.lineTo(35 * scale, -5 * scale);
                tail.lineTo(40 * scale, 0);
                tail.lineTo(35 * scale, 5 * scale);
                tail.closePath();
            } else if (dragonData.traits.tailType === 'smooth' || dragonData.traits.tailType === 'wispy') {
                // Smooth/wispy tail
                tail.drawEllipse(30 * scale, 0, 12 * scale, 6 * scale);
            } else {
                // Default thick tail
                tail.drawEllipse(28 * scale, 0, 15 * scale, 8 * scale);
            }
            tail.endFill();
            
            // Dragon wings (if has wings) - same as companion dragon
            let leftWing = null, rightWing = null;
            if (dragonData.traits.hasWings) {
                leftWing = new PIXI.Graphics();
                leftWing.beginFill(dragonData.traits.accentColor);
                leftWing.moveTo(-10 * scale, -10 * scale);
                leftWing.lineTo(-25 * scale, -20 * scale);
                leftWing.lineTo(-15 * scale, -35 * scale);
                leftWing.lineTo(0, -25 * scale);
                leftWing.closePath();
                leftWing.endFill();
                
                rightWing = new PIXI.Graphics();
                rightWing.beginFill(dragonData.traits.accentColor);
                rightWing.moveTo(10 * scale, -10 * scale);
                rightWing.lineTo(25 * scale, -20 * scale);
                rightWing.lineTo(15 * scale, -35 * scale);
                rightWing.lineTo(0, -25 * scale);
                rightWing.closePath();
                rightWing.endFill();
            }
            
            // Dragon horns (if has horns) - same as companion dragon
            let leftHorn = null, rightHorn = null;
            if (dragonData.traits.hasHorns) {
                leftHorn = new PIXI.Graphics();
                leftHorn.beginFill(dragonData.traits.accentColor);
                leftHorn.moveTo(-25 * scale, -8 * scale);
                leftHorn.lineTo(-30 * scale, -18 * scale);
                leftHorn.lineTo(-22 * scale, -15 * scale);
                leftHorn.closePath();
                leftHorn.endFill();
                
                rightHorn = new PIXI.Graphics();
                rightHorn.beginFill(dragonData.traits.accentColor);
                rightHorn.moveTo(-15 * scale, -8 * scale);
                rightHorn.lineTo(-20 * scale, -18 * scale);
                rightHorn.lineTo(-12 * scale, -15 * scale);
                rightHorn.closePath();
                rightHorn.endFill();
            }
            
            // Dragon legs - same as companion dragon (4 separate legs)
            const leg1 = new PIXI.Graphics();
            leg1.beginFill(dragonData.traits.bodyColor);
            leg1.drawEllipse(-15 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg1.endFill();
            
            const leg2 = new PIXI.Graphics();
            leg2.beginFill(dragonData.traits.bodyColor);
            leg2.drawEllipse(-5 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg2.endFill();
            
            const leg3 = new PIXI.Graphics();
            leg3.beginFill(dragonData.traits.bodyColor);
            leg3.drawEllipse(5 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg3.endFill();
            
            const leg4 = new PIXI.Graphics();
            leg4.beginFill(dragonData.traits.bodyColor);
            leg4.drawEllipse(15 * scale, 12 * scale, 4 * scale, 8 * scale);
            leg4.endFill();
            
            // Dragon eyes - same as companion dragon
            const eyes = new PIXI.Graphics();
            eyes.beginFill(dragonData.traits.eyeColor);
            eyes.drawCircle(-25 * scale, -8 * scale, 2 * scale);
            eyes.drawCircle(-20 * scale, -8 * scale, 2 * scale);
            eyes.endFill();
            
            // Assemble dragon sprite in proper order (same as companion)
            dragonContainer.addChild(tail);
            dragonContainer.addChild(leg1);
            dragonContainer.addChild(leg2);
            dragonContainer.addChild(leg3);
            dragonContainer.addChild(leg4);
            dragonContainer.addChild(body);
            dragonContainer.addChild(head);
            
            if (leftWing && rightWing) {
                dragonContainer.addChild(leftWing);
                dragonContainer.addChild(rightWing);
            }
            
            if (leftHorn && rightHorn) {
                dragonContainer.addChild(leftHorn);
                dragonContainer.addChild(rightHorn);
            }
            
            dragonContainer.addChild(eyes);
            
            // Position dragon to face right (towards enemy)
            dragonContainer.x = 40;
            dragonContainer.y = 45;
            
            battleDragonApp.stage.addChild(dragonContainer);
            container.appendChild(battleDragonApp.view);
            
            return battleDragonApp;
        }

        function createBattleMonsterSprite(monsterData) {
            const container = document.getElementById('battleMonsterSprite');
            container.innerHTML = '';
            
            const monsterDiv = document.createElement('div');
            monsterDiv.style.position = 'relative';
            monsterDiv.style.width = '50px';
            monsterDiv.style.height = '40px';
            
            if (monsterData.archetype === 'humanoid') {
                const skinColor = monsterData.colors?.skin || '#CD853F';
                const equipment = monsterData.equipment || monsterData.traits?.equipment;
                
                // Body (with armor if equipped)
                const body = document.createElement('div');
                body.style.position = 'absolute';
                body.style.width = '20px';
                body.style.height = '25px';
                body.style.backgroundColor = equipment?.armor ? equipment.armor.color : '#8B4513';
                body.style.borderRadius = '20% 20% 0% 0%';
                body.style.left = '15px';
                body.style.bottom = '5px';
                body.style.border = '1px solid #333';
                monsterDiv.appendChild(body);
                
                // Head
                const head = document.createElement('div');
                head.style.position = 'absolute';
                head.style.width = '15px';
                head.style.height = '15px';
                head.style.backgroundColor = skinColor;
                head.style.borderRadius = '50%';
                head.style.left = '17px';
                head.style.bottom = '25px';
                head.style.border = '1px solid #333';
                monsterDiv.appendChild(head);
                
                // Helmet (if equipped)
                if (equipment?.helmet) {
                    const helmet = document.createElement('div');
                    helmet.style.position = 'absolute';
                    helmet.style.width = '17px';
                    helmet.style.height = '12px';
                    helmet.style.backgroundColor = equipment.helmet.color;
                    helmet.style.borderRadius = '50% 50% 20% 20%';
                    helmet.style.left = '16px';
                    helmet.style.bottom = '30px';
                    helmet.style.border = '1px solid #222';
                    helmet.style.zIndex = '10';
                    monsterDiv.appendChild(helmet);
                }
                
                // Arms
                const leftArm = document.createElement('div');
                leftArm.style.position = 'absolute';
                leftArm.style.width = '8px';
                leftArm.style.height = '15px';
                leftArm.style.backgroundColor = skinColor;
                leftArm.style.borderRadius = '50%';
                leftArm.style.left = '8px';
                leftArm.style.bottom = '15px';
                leftArm.style.border = '1px solid #333';
                monsterDiv.appendChild(leftArm);
                
                const rightArm = document.createElement('div');
                rightArm.style.position = 'absolute';
                rightArm.style.width = '8px';
                rightArm.style.height = '15px';
                rightArm.style.backgroundColor = skinColor;
                rightArm.style.borderRadius = '50%';
                rightArm.style.left = '34px';
                rightArm.style.bottom = '15px';
                rightArm.style.border = '1px solid #333';
                monsterDiv.appendChild(rightArm);
                
                // Weapon (if equipped)
                if (equipment?.weapon) {
                    const weapon = document.createElement('div');
                    weapon.style.position = 'absolute';
                    weapon.style.width = '12px';
                    weapon.style.height = '3px';
                    weapon.style.backgroundColor = equipment.weapon.color;
                    weapon.style.borderRadius = '50%';
                    weapon.style.left = '2px';
                    weapon.style.bottom = '20px';
                    weapon.style.border = '1px solid #222';
                    weapon.style.transform = 'rotate(-45deg)';
                    weapon.style.transformOrigin = 'right center';
                    monsterDiv.appendChild(weapon);
                    
                    // Weapon icon overlay
                    const weaponIcon = document.createElement('div');
                    weaponIcon.style.position = 'absolute';
                    weaponIcon.style.left = '0px';
                    weaponIcon.style.bottom = '32px';
                    weaponIcon.style.fontSize = '8px';
                    weaponIcon.style.zIndex = '20';
                    weaponIcon.innerHTML = equipment.weapon.icon;
                    monsterDiv.appendChild(weaponIcon);
                }
                
                // Belt/accessories
                if (equipment?.accessories?.length > 0) {
                    const belt = equipment.accessories.find(acc => acc.key === 'belt');
                    if (belt) {
                        const beltDiv = document.createElement('div');
                        beltDiv.style.position = 'absolute';
                        beltDiv.style.width = '22px';
                        beltDiv.style.height = '3px';
                        beltDiv.style.backgroundColor = belt.color;
                        beltDiv.style.left = '14px';
                        beltDiv.style.bottom = '15px';
                        beltDiv.style.border = '1px solid #222';
                        monsterDiv.appendChild(beltDiv);
                    }
                }
                
            } else if (monsterData.archetype === 'beast') {
                // Body
                const body = document.createElement('div');
                body.style.position = 'absolute';
                body.style.width = '35px';
                body.style.height = '15px';
                body.style.backgroundColor = '#654321';
                body.style.borderRadius = '50%';
                body.style.left = '8px';
                body.style.bottom = '10px';
                body.style.border = '1px solid #333';
                monsterDiv.appendChild(body);
                
                // Head
                const head = document.createElement('div');
                head.style.position = 'absolute';
                head.style.width = '18px';
                head.style.height = '12px';
                head.style.backgroundColor = '#654321';
                head.style.borderRadius = '60% 40%';
                head.style.left = '0px';
                head.style.bottom = '15px';
                head.style.border = '1px solid #333';
                monsterDiv.appendChild(head);
                
                // Legs
                for (let i = 0; i < 4; i++) {
                    const leg = document.createElement('div');
                    leg.style.position = 'absolute';
                    leg.style.width = '4px';
                    leg.style.height = '10px';
                    leg.style.backgroundColor = '#654321';
                    leg.style.left = (10 + i * 8) + 'px';
                    leg.style.bottom = '0px';
                    leg.style.border = '1px solid #333';
                    monsterDiv.appendChild(leg);
                }
                
            } else { // magical
                // Ethereal body
                const body = document.createElement('div');
                body.style.position = 'absolute';
                body.style.width = '25px';
                body.style.height = '30px';
                body.style.background = 'radial-gradient(circle, #9370DB, #4B0082)';
                body.style.borderRadius = '50%';
                body.style.left = '12px';
                body.style.bottom = '5px';
                body.style.border = '1px solid #8A2BE2';
                body.style.opacity = '0.8';
                monsterDiv.appendChild(body);
                
                // Magical aura
                const aura = document.createElement('div');
                aura.style.position = 'absolute';
                aura.style.width = '35px';
                aura.style.height = '40px';
                aura.style.background = 'radial-gradient(circle, transparent 60%, #9370DB 80%)';
                aura.style.borderRadius = '50%';
                aura.style.left = '8px';
                aura.style.bottom = '0px';
                aura.style.opacity = '0.3';
                aura.style.animation = 'pulse 2s infinite';
                monsterDiv.appendChild(aura);
            }
            
            container.appendChild(monsterDiv);
            return monsterDiv;
        }

        function animateAttack(attacker, target, effectType = 'normal') {
            const attackEffects = document.getElementById('attackEffects');
            
            // Create attack effect
            const effect = document.createElement('div');
            effect.style.position = 'absolute';
            effect.style.width = '20px';
            effect.style.height = '20px';
            effect.style.borderRadius = '50%';
            effect.style.pointerEvents = 'none';
            
            if (effectType === 'fire') {
                effect.style.background = 'radial-gradient(circle, #ff6600, #ff0000)';
                effect.innerHTML = 'üî•';
            } else if (effectType === 'ice') {
                effect.style.background = 'radial-gradient(circle, #00ccff, #0066cc)';
                effect.innerHTML = '‚ùÑÔ∏è';
            } else if (effectType === 'earth') {
                effect.style.background = 'radial-gradient(circle, #8B4513, #654321)';
                effect.innerHTML = 'üåç';
            } else if (effectType === 'storm') {
                effect.style.background = 'radial-gradient(circle, #ffff00, #6666ff)';
                effect.innerHTML = '‚ö°';
            } else if (effectType === 'shadow') {
                effect.style.background = 'radial-gradient(circle, #4B0082, #000000)';
                effect.innerHTML = 'üåô';
            } else {
                effect.style.background = 'radial-gradient(circle, #ffffff, #cccccc)';
                effect.innerHTML = 'üí•';
            }
            
            effect.style.fontSize = '16px';
            effect.style.display = 'flex';
            effect.style.alignItems = 'center';
            effect.style.justifyContent = 'center';
            
            // Position based on attacker
            if (attacker === 'dragon') {
                effect.style.left = '80px';
                effect.style.top = '30px';
                // Animate towards enemy
                effect.style.animation = 'attackRight 0.5s ease-out forwards';
            } else {
                effect.style.right = '80px';
                effect.style.top = '30px';
                // Animate towards dragon
                effect.style.animation = 'attackLeft 0.5s ease-out forwards';
            }
            
            attackEffects.appendChild(effect);
            
            // Animate target hit
            const targetSprite = attacker === 'dragon' ? 
                document.getElementById('battleMonsterSprite') : 
                document.getElementById('battleDragonSprite');
            
            targetSprite.style.animation = 'hit 0.3s ease-in-out';
            
            // Clean up effects
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                targetSprite.style.animation = '';
            }, 800);
        }
    </script>
    
    <!-- Version info -->
    <div style="position: fixed; bottom: 5px; right: 5px; font-size: 10px; color: rgba(255,255,255,0.5); font-family: monospace; pointer-events: none;">
        v1.1.0 | Complete Inventory System
    </div>
</body>
</html>