import{P as e,i as t,j as n,f as a,k as r,B as s,l as i,m as o,H as l,W as c,A as f,I as u,n as h,o as w,p,C as y,b as d,E as b,q as S,r as A,s as g,F as m,t as z,u as C,v as k}from"./index-sKWi3Pmp.js";function O(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function v(e){const t=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),n=new Uint8Array(function(e){let t=e.byteLength;const n=new Array;let a=0;const r=new DataView(e);for(;t>0;){const e=r.getInt8(a++);if(e<0){const s=-e;t-=s+1;for(let e=0;e<s;e++)n.push(r.getUint8(a++))}else{const s=e;t-=2;const i=r.getUint8(a++);for(let e=0;e<s+1;e++)n.push(i)}}return n}(t)),a=new Uint8Array(n.length);return h(n),w(n,a),new DataView(a.buffer)}function x(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),a=new Uint8Array(n.length);return h(n),w(n,a),new DataView(a.buffer)}function E(e){const t=e.array.slice(e.offset.value,e.offset.value+e.size),n=fflate.unzlibSync(t),a=e.lines*e.channels*e.width,r=1==e.type?new Uint16Array(a):new Uint32Array(a);let s=0,i=0;const o=new Array(4);for(let l=0;l<e.lines;l++)for(let t=0;t<e.channels;t++){let t=0;switch(e.type){case 1:o[0]=s,o[1]=o[0]+e.width,s=o[1]+e.width;for(let a=0;a<e.width;++a){t+=n[o[0]++]<<8|n[o[1]++],r[i]=t,i++}break;case 2:o[0]=s,o[1]=o[0]+e.width,o[2]=o[1]+e.width,s=o[2]+e.width;for(let a=0;a<e.width;++a){t+=n[o[0]++]<<24|n[o[1]++]<<16|n[o[2]++]<<8,r[i]=t,i++}}}return new DataView(r.buffer)}function U(e){const n=e.viewer,a={value:e.offset.value},h=new Uint16Array(e.width*e.scanlineBlockSize*(e.channels*e.type)),w=new Uint8Array(s);let y=0;const d=new Array(e.channels);for(let t=0;t<e.channels;t++)d[t]={},d[t].start=y,d[t].end=d[t].start,d[t].nx=e.width,d[t].ny=e.lines,d[t].size=e.type,y+=d[t].nx*d[t].ny*d[t].size;const b=r(n,a),S=r(n,a);if(S>=s)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(b<=S)for(let t=0;t<S-b+1;t++)w[t+b]=i(n,a);const A=new Uint16Array(p),g=o(w,A),m=t(n,a);l(e.array,n,a,m,h,y);for(let t=0;t<e.channels;++t){const e=d[t];for(let n=0;n<d[t].size;++n)c(h,e.start+n,e.nx,e.size,e.ny,e.nx*e.size,g)}f(A,h,y);let z=0;const C=new Uint8Array(h.buffer.byteLength);for(let t=0;t<e.lines;t++)for(let n=0;n<e.channels;n++){const e=d[n],t=e.nx*e.size,a=new Uint8Array(h.buffer,e.end*u,t*u);C.set(a,z),z+=t*u,e.end+=t}return new DataView(C.buffer)}class L{constructor(){this.supportCascades=!1}loadCubeData(e,t,n,a,r){throw".exr not supported in Cube."}async loadData(s,i,o){const l=new DataView(s.buffer),c={value:0},f=function(r,s){if(20000630!=r.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const i=r.getUint8(4),o=r.getUint8(5),l={singleTile:!!(2&o),longName:!!(4&o),deepFormat:!!(8&o),multiPart:!!(16&o)};s.value=8;const c={};let f=!0;for(;f;){const i=e(r.buffer,s);if(i){const o=e(r.buffer,s),l=t(r,s),f=n(r,s,o,l);void 0===f?a.Warn(`Unknown header attribute type ${o}'.`):c[i]=f}else f=!1}if(-5&o)throw new Error("Unsupported file format");return{version:i,spec:l,...c}}(l,c),h=await async function(e,t,n,a){const s={size:0,viewer:t,array:new Uint8Array(t.buffer),offset:n,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,channels:e.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(e.compression){case y.NO_COMPRESSION:s.lines=1,s.uncompress=O;break;case y.RLE_COMPRESSION:s.lines=1,s.uncompress=v;break;case y.ZIPS_COMPRESSION:s.lines=1,s.uncompress=x,await d.LoadScriptAsync(b.FFLATEUrl);break;case y.ZIP_COMPRESSION:s.lines=16,s.uncompress=x,await d.LoadScriptAsync(b.FFLATEUrl);break;case y.PIZ_COMPRESSION:s.lines=32,s.uncompress=U;break;case y.PXR24_COMPRESSION:s.lines=16,s.uncompress=E,await d.LoadScriptAsync(b.FFLATEUrl);break;default:throw new Error(y[e.compression]+" is unsupported")}s.scanlineBlockSize=s.lines;const i={};for(const r of e.channels)switch(r.name){case"Y":case"R":case"G":case"B":case"A":i[r.name]=!0,s.type=r.pixelType}let o=!1;if(i.R&&i.G&&i.B)o=!i.A,s.outputChannels=4,s.decodeChannels={R:0,G:1,B:2,A:3};else{if(!i.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");s.outputChannels=1,s.decodeChannels={Y:0}}if(1===s.type)switch(a){case S.Float:s.getter=A,s.inputSize=u;break;case S.HalfFloat:s.getter=r,s.inputSize=u}else{if(2!==s.type)throw new Error("Unsupported pixelType "+s.type+" for "+e.compression);switch(a){case S.Float:s.getter=z,s.inputSize=m;break;case S.HalfFloat:s.getter=g,s.inputSize=m}}s.blockCount=s.height/s.scanlineBlockSize;for(let r=0;r<s.blockCount;r++)C(t,n);const l=s.width*s.height*s.outputChannels;switch(a){case S.Float:s.byteArray=new Float32Array(l),s.textureType=1,o&&s.byteArray.fill(1,0,l);break;case S.HalfFloat:s.byteArray=new Uint16Array(l),s.textureType=2,o&&s.byteArray.fill(15360,0,l);break;default:throw new Error("Unsupported type: "+a)}let c=0;for(const r of e.channels)void 0!==s.decodeChannels[r.name]&&(s.channelLineOffsets[r.name]=c*s.width),c+=2*r.pixelType;return s.bytesPerLine=s.width*c,s.outLineWidth=s.width*s.outputChannels,"INCREASING_Y"===e.lineOrder?s.scanOrder=e=>e:s.scanOrder=e=>s.height-1-e,4==s.outputChannels?(s.format=5,s.linearSpace=!0):(s.format=6,s.linearSpace=!1),s}(f,l,c,b.DefaultOutputType);!function(e,n,a,r){const s={value:0};for(let i=0;i<e.height/e.scanlineBlockSize;i++){const o=k(a,r)-n.dataWindow.yMin;e.size=t(a,r),e.lines=o+e.scanlineBlockSize>e.height?e.height-o:e.scanlineBlockSize;const l=e.size<e.lines*e.bytesPerLine&&e.uncompress?e.uncompress(e):O(e);r.value+=e.size;for(let t=0;t<e.scanlineBlockSize;t++){const a=i*e.scanlineBlockSize,r=t+e.scanOrder(a);if(r>=e.height)continue;const o=t*e.bytesPerLine,c=(e.height-1-r)*e.outLineWidth;for(let t=0;t<e.channels;t++){const a=n.channels[t].name,r=e.channelLineOffsets[a],i=e.decodeChannels[a];if(void 0!==i){s.value=o+r;for(let t=0;t<e.width;t++){const n=c+t*e.outputChannels+i;e.byteArray&&(e.byteArray[n]=e.getter(l,s))}}}}}}(h,f,l,c);o(f.dataWindow.xMax-f.dataWindow.xMin+1,f.dataWindow.yMax-f.dataWindow.yMin+1,i.generateMipMaps,!1,()=>{const e=i.getEngine();i.format=f.format,i.type=h.textureType,i.invertY=!1,i._gammaSpace=!f.linearSpace,h.byteArray&&e._uploadDataToTextureDirectly(i,h.byteArray,0,0,void 0,!0)})}}export{L as _ExrTextureLoader};
//# sourceMappingURL=exrTextureLoader-Dddwu5wS.js.map
